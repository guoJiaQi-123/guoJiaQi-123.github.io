<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>7.接雨水</title>
    <link href="/2025/01/15/7-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2025/01/15/7-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h1><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="/img/post/2-%E6%8E%A5%E9%9B%A8%E6%B0%B4.assets/rainwatertrap.png" alt="示例"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><blockquote><p> <strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul></blockquote><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><p>为什么使用单调栈？</p><p>因为如果柱子的高度是单调递减的，那么肯定存不下雨水，这样我们就将单调递减的柱子加入单调栈，这样如果一个高的柱子入栈，会导致栈顶元素出栈，我们就可以做出栈的时候进行水的容量计算「<strong>只有出栈的时候可能会存雨水</strong>」</p></blockquote><p><img src="/img/post/2-%E6%8E%A5%E9%9B%A8%E6%B0%B4.assets/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E5%8A%A8%E7%94%BB.gif" alt="入栈动画演示"></p><ul><li>遍历所有的柱子，对于每个柱子，将其信息存储在 <code>right</code> 中。</li><li>当栈不为空且栈顶元素的高度小于 <code>right</code> 的高度时，从栈中弹出元素 <code>pop</code>，并取栈顶元素作为 <code>left</code>。</li><li>计算 <code>left</code> 和 <code>right</code> 之间能存储雨水的空间，即根据宽度和高度的计算（宽度为 <code>right.index - left.index - 1</code>，高度为 <code>Math.min(right.height, left.height) - pop.height</code>），将计算结果累加到 <code>sum</code> 中。</li><li>最终得到的 <code>sum</code> 就是整个柱状图能存储的雨水总量。</li></ul><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果柱子的高度是单调递减的，那么肯定存不下雨水</span><br><span class="hljs-comment">// 如果出现了一个比之前柱子高的柱子，才有可能有空间能够存下雨水</span><br><span class="hljs-comment">// 使用一个单调 栈存放每个柱子的高度，当新来的柱子更高时，不满足单调栈的规则，需要弹出栈顶那些高度低的柱子的时候 计算雨水容量</span><br><span class="hljs-comment">// 此时涉及到三个变量，一个是刚加入的柱子，命名为right，一个是被弹出的柱子，命名为pop，还有一个是被弹出柱子左侧的柱子，命名left</span><br><span class="hljs-comment">// 水的容量 = (right的索引-left的索引-1) * min(right.height,left.height) - pop.height</span><br><span class="hljs-comment">// 因为对于每个柱子我们都需要用它的索引和高度两个状态，因此我们封装一个Data类来描述柱子</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>    LinkedList&lt;Data&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; heights.length; i++) &#123;<br>        <span class="hljs-type">Data</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>(heights[i], i); <span class="hljs-comment">// 即将放入单调栈中的柱子</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().height &lt; right.height) &#123; <span class="hljs-comment">// 查看单调栈顶元素是否小于准备入栈的元素</span><br>            <span class="hljs-type">Data</span> <span class="hljs-variable">pop</span> <span class="hljs-operator">=</span> stack.pop(); <span class="hljs-comment">// 从栈中pop出的柱子</span><br>            <span class="hljs-type">Data</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> stack.peek(); <span class="hljs-comment">// 栈中pop出柱子后的栈顶柱子就是原先pop柱子左侧的柱子</span><br>            <span class="hljs-comment">// 如果左侧的柱子不为null</span><br>            <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 计算水的容量并累加</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> right.index - left.index - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> Math.min(right.height, left.height) - pop.height;<br>                sum += width * height;<br>            &#125;<br>        &#125;<br>        stack.push(right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> height; <span class="hljs-comment">// 柱子高度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index; <span class="hljs-comment">// 柱子的索引</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Data</span><span class="hljs-params">(<span class="hljs-type">int</span> height, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-built_in">this</span>.height = height;<br>        <span class="hljs-built_in">this</span>.index = index;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.三数之和</title>
    <link href="/2025/01/15/6-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2025/01/15/6-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h1><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><blockquote><p><strong>注意</strong>：答案中不可以包含重复的三元组。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><p>视频讲解：<a href="https://www.bilibili.com/video/BV1rv4y1H7o6/?p=178">https://www.bilibili.com/video/BV1rv4y1H7o6/?p=178</a></p></blockquote><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>这道题目使用双指针法 要比哈希法高效一些，那么来讲解一下具体实现的思路。</p><p>动画效果如下：</p><p><img src="/img/post/1-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.assets/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="三数之和"></p><p><strong>拿这个nums数组来举例，首先将数组排序，然后有一层</strong>for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。（<strong>相当于三个指针）</strong></p><p>依然还是在数组中找到 abc 使得a + b +c &#x3D;0，我们这里相当于<code>a = nums[i]，b = nums[left]，c = nums[right]</code>。</p><p>接下来如何移动left 和right呢， 如果<strong>nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</strong></p><p>如果 <strong>nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。</strong></p><h3 id="去重逻辑的思考"><a href="#去重逻辑的思考" class="headerlink" title="去重逻辑的思考"></a>去重逻辑的思考</h3><h4 id="a的去重"><a href="#a的去重" class="headerlink" title="a的去重"></a>a的去重</h4><p>说到去重，其实主要考虑三个数的去重。 <strong>a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]</strong></p><p>a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。</p><p>但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。</p><p>有同学可能想，这不都一样吗。</p><p>其实不一样！</p><p>都是和 nums[i]进行比较，是比较它的前一个，还是比较它的后一个。</p><p>如果我们的写法是 这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 去重操作</span><br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</p><p>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</p><p>所以这里是有两个重复的维度。</p><p>那么应该这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。</p><p><strong>这是一个非常细节的思考过程。</strong></p><h4 id="b与c的去重"><a href="#b与c的去重" class="headerlink" title="b与c的去重"></a>b与c的去重</h4><p>很多同学写本题的时候，去重的逻辑多加了 对right 和left 的去重：（代码中注释部分）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) &#123;<br>        right--;<br>        <span class="hljs-comment">// 去重 right</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="hljs-number">1</span>]) right--;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) &#123;<br>        left++;<br>        <span class="hljs-comment">// 去重 left</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="hljs-number">1</span>]) left++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但细想一下，这种去重其实对提升程序运行效率是没有帮助的。</p><p>拿right去重为例，即使不加这个去重逻辑，依然根据 <code>while (right &gt; left)</code> 和 <code>if (nums[i] + nums[left] + nums[right] &gt; 0)</code> 去完成right– 的操作。</p><p>多加了 <code>while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;</code> 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少 判断的逻辑。</p><p><strong>最直白的思考过程，就是right还是一个数一个数的减下去的，所以在哪里减的都是一样的。</strong></p><p>所以这种去重 是可以不加的。 仅仅是 把去重的逻辑提前了而已</p><p>而真正去重b和c的代码应该放在找到一个三元组之后，对b 和 c去重，<strong>并且去重后需要对left和right同时收缩</strong></p><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><h3 id="三指针"><a href="#三指针" class="headerlink" title="三指针"></a>三指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 三指针</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 先排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// 排序后数组的第一个值如果大于0，则三数之和后一定不可能有等于0的情况，直接返回</span><br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        使用i指针固定一个值a,使用left指针固定一个值b，使用right指针固定一个值c</span><br><span class="hljs-comment">        指针 i 的取值范围 [0,nums.length-3],因为后面最少还需要留两个位置给right和left</span><br><span class="hljs-comment">     */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">// 对a进行去重</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-comment">// 三数之和</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br>                <span class="hljs-comment">// 如果三数之和大于0，则需要将right--，反之将left++</span><br>                <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                    left++;<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 找到第一个三数和为0，加入结果集合后对数字b和c进行去重</span><br>                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                    left++;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回溯算法，可同时解决四数之和等问题</span><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum3</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       Arrays.sort(nums); <span class="hljs-comment">// 排序</span><br>       dfs(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, nums, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(), result);<br>       <span class="hljs-keyword">return</span> result;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> n 三数之和 n == 3  四数之和 n == 4</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> i 左边界</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> j 右边界</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> nums 数组</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> target 目标值</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> stack 栈 回溯用</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> result 结果集合 -&gt; 存放最后的结果</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target,</span><br><span class="hljs-params">                   LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;<br>       <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>           <span class="hljs-comment">// 如果n==2,走求解两数之和的逻辑</span><br>           towSum(nums, i, j, target, stack, result);<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt; j - (n - <span class="hljs-number">2</span>); k++) &#123;<br>           <span class="hljs-keyword">if</span> (k &gt; i &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 去重</span><br>               <span class="hljs-keyword">continue</span>;<br>           &#125;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[k];<br>           stack.push(num); <span class="hljs-comment">// 固定一个值</span><br>           dfs(n - <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>, j, nums, target - num, stack, result);<br>           stack.pop();<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 两数之和</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> i</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> j</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> target</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> stack</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> result</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">towSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> target,</span><br><span class="hljs-params">                       LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;<br><br>       <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[j];<br>           <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>               i++;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>               j--;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(stack);<br>               list.add(nums[i]);<br>               list.add(nums[j]);<br>               result.add(list);<br>               <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 去重</span><br>                   i++;<br>               &#125;<br>               <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 去重</span><br>                   j--;<br>               &#125;<br>               i++;<br>               j--;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码随想录：<a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html</a><br>黑马满一航老师的数据结构「重点讲了回溯实现」：<a href="https://www.bilibili.com/video/BV1rv4y1H7o6/?p=178">https://www.bilibili.com/video/BV1rv4y1H7o6/?p=178</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.盛水最多的容器</title>
    <link href="/2025/01/15/5-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2025/01/15/5-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h1><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p>**说明：**你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="/img/post/5-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8.assets/question_11.jpg" alt="盛水最多的容器"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>核心思想：<span class="label label-info"> 双指针</span></p><p>定义两个指针 i 和 j，分别在数组的两端，while 循环条件为两个指针不相遇</p><p>然后每次取两个指针所在索引处的值作为盛放水的挡板，因为只能取最短的挡板作为边界才能存放水，因此判断哪个挡板更低，对应到数组上就是哪个指针对应的数组的值更低</p><p>通过这个值，和 x 轴的长度，也就是（j-i）来计算当前容量，然后维护一个max记录最大容量，每次计算完成后，选择低的哪个挡板指针向中心靠拢</p><div class="note note-primary">            <p>「只有移动低的挡板到更高的挡板容量才有可能更大，否则一直按照低的挡板算容量，容量不可能再变大了」</p>          </div><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> OldGj 2025/1/9</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@apiNote</span> 11. 盛最多水的容器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_005_maxArea</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">if</span> (height[i] &lt; height[j]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> (j - i) * height[i];<br>                max = Math.max(area, max);<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> (j - i) * height[j];<br>                max = Math.max(area, max);<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.移动零</title>
    <link href="/2025/01/15/4-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <url>/2025/01/15/4-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[0,1,0,3,12]</span><br>输出: <span class="hljs-string">[1,3,12,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[0]</span><br>输出: <span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><p>**进阶：**你能尽量减少完成的操作次数吗？</p><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>两种思路，一种思路是<span class="label label-info"> 顺序遍历数组</span>，再定义一个指针从0开始构建数组，遍历到非0数，则将其放到构建数组的指针索引处，遍历完毕，将构建数组指针后面的所有数置0【简单说就是，将数组中所有的非0数，按照相对顺序放到数组前面的位置，然后将后面的位置直接全部置为0。<strong>【对应下面方法1】</strong></p><p>第二种思路是使用<span class="label label-info"> 双指针</span>，<strong>左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</strong></p><p>右指针不断向右移动，<strong>每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</strong></p><p>注意到以下性质：</p><ol><li>左指针左边均为非零数；</li><li>右指针左边直到左指针处均为零。</li></ol><p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的<strong>相对顺序并未改变。【对应下面方法2】</strong></p><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><h3 id="顺序遍历数组"><a href="#顺序遍历数组" class="headerlink" title="顺序遍历数组"></a>顺序遍历数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// 慢指针构建数组，快指针扫描非零数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fast &lt; nums.length; fast++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] != <span class="hljs-number">0</span>) &#123;<br>            nums[slow] = nums[fast];<br>            slow++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 快指针遍历完后，将慢指针后的所有元素都置为零</span><br>    <span class="hljs-keyword">for</span> (; slow &lt; nums.length; slow++) &#123;<br>        nums[slow] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>        <span class="hljs-keyword">if</span> (nums[right] != <span class="hljs-number">0</span>) &#123;<br>            swap(nums, left, right); <span class="hljs-comment">// 将左指针的零与右指针的非零数交换</span><br>            left++;<br>        &#125;<br>        right++;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>    nums[left] = nums[right];<br>    nums[right] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.最长连续序列</title>
    <link href="/2025/01/15/3-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <url>/2025/01/15/3-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h1><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[100,4,200,1,3,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 <span class="hljs-string">[1, 2, 3, 4]</span>。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,3,7,2</span>,<span class="hljs-number">5,8,4,6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><div class="note note-primary">            <p>核心思想：使用set完成去重以及快速查找一个值是否存在</p>          </div><p>利用 <code>HashSet</code> 的特性，对于每个元素，<strong>如果它是一个连续序列的起始元素（即它的前一个元素不在集合中）</strong>，就计算从它开始的连续序列长度。通过遍历和检查元素及其相邻元素是否在集合中，找到最长的连续序列长度。</p><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-comment">// 使用set去重</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        set.add(num);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">longestStreak</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最长序列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : set) &#123;<br>        <span class="hljs-keyword">if</span> (!set.contains(num - <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// 如果num-1不在集合中，则以他为序列第一个元素，判断最长序列</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">currentNum</span> <span class="hljs-operator">=</span> num;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currentStreak</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (set.contains(currentNum + <span class="hljs-number">1</span>)) &#123;<br>                currentNum += <span class="hljs-number">1</span>;<br>                currentStreak += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 更新最长序列长度</span><br>            longestStreak = Math.max(longestStreak, currentStreak);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> longestStreak;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.字母异位词分组</title>
    <link href="/2025/01/15/2-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <url>/2025/01/15/2-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h1><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>核心点在于如何判断是否是字母异位词，我们可以从字母异位词的结构入手，发现每个字母异位词中的每个字符 出现的次数都是一样的，只是顺序不一样，这里有两种实现思路：</p><ol><li>自定义一个ArrayKey类型，专门用于判断是否是字母异位词，原理是，在ArrayKey中维护一个长度位26的数组，每一位存放一个字母出现的个数，在有参构造中，拿到字符串后，遍历每个字符，将对应的索引处的元素加一，重写ArrayKey的equals和hashCode方法，即可实现通过数组比较是否是字母异位词（如果是字母异位词，那么肯定有相同的数组，因为每个字符出现的次数都一样）</li><li>第二种方法是基于排序的，既然字母异位词只是字符排列不相同的单词，那么我们可以将每个单词都进行一个排序，这样，如果是字母异位词，那么排序后的字符串一定都相等，实现上就是先将字符串转换为字符数组，然后使用Arrays.sort方法对字符数组进行排序后，再转回字符串，如果排序后的字符串相同，肯定是字母异位词</li></ol><p>判断字母是不是异位词的问题解决后，我们就可以通过异位词判断之前是否添加过该异位词对于的列表，如果没有，则创建新的列表放入map中，如果有，则取旧的列表，直接将当前字符串添加到列表中即可</p><div class="note note-primary">            <p>map的key表示可以判断是否是字母异位词的结构，方法一是一个ArrayKey对象，方法二则是排序后的字符串</p><p>map的value则是当前类型的字母异位词对应的存放原字符串的列表</p>          </div><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_2_groupAnagrams</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过一个数组判定字母异位词</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayKey</span> &#123;<br>        <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object object)</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == object) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (object == <span class="hljs-literal">null</span> || getClass() != object.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">ArrayKey</span> <span class="hljs-variable">arrayKey</span> <span class="hljs-operator">=</span> (ArrayKey) object;<br>            <span class="hljs-keyword">return</span> Objects.deepEquals(array, arrayKey.array);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> Arrays.hashCode(array);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayKey</span><span class="hljs-params">(String str)</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str.charAt(i);<br>                array[c - <span class="hljs-number">97</span>]++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        HashMap&lt;ArrayKey, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-comment">// 字母异位词的ArrayKey一定相同</span><br>            <span class="hljs-type">ArrayKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayKey</span>(str);<br>            List&lt;String&gt; list = map.computeIfAbsent(key, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>            list.add(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所有的字母异位词排序后都一样</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> strs</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>    <span class="hljs-comment">// 「key:排序后的字母异位词，value:所有的字母异位词」</span><br>    HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>        <span class="hljs-comment">// 转字符数组</span><br>        <span class="hljs-type">char</span>[] charArray = str.toCharArray();<br>        <span class="hljs-comment">// 排序</span><br>        Arrays.sort(charArray);<br>        <span class="hljs-comment">// 转字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> Arrays.toString(charArray);<br>        <span class="hljs-comment">// 存在则返回链表，不存在则创建新的链表</span><br>        List&lt;String&gt; list = map.computeIfAbsent(string, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        list.add(str);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.values());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.两数之和</title>
    <link href="/2025/01/15/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2025/01/15/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong><br>整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p><strong>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</strong></p><p>本题呢，我就<strong>需要一个集合来存放我们遍历过的元素</strong>，然后在遍历数组的时候去询问这个集合，<strong>某元素是否遍历过，也就是<br>是否出现在这个集合。</strong></p><p>那么我们就应该想到使用哈希法了。</p><p>因为本题，<strong>我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标</strong>，需要使用 key value结构来存放，<span class="label label-info"> key来存元素，value来存下标</span>，那么使用map正合适。</p><p>再来看一下使用数组和set来做哈希法的局限。</p><ul><li><strong>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费</strong>。</li><li><strong>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和<br>y的下标。所以set 也不能用</strong>。</li></ul><p>此时就要选择另一种数据结构：map ，map是一种key — value的存储结构，**可以用key保存数值，用value再保存数值所在的下标。</p><img src="/img/post/1-两数之和.assets/image-20250115195537832.png" alt="两数之和" style="zoom:50%;" /><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_001_twoSum</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 「key:数组元素  value：元素对应数组下标」</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (map.containsKey(target - num)) &#123;<br>                <span class="hljs-comment">// 如果map中存了和当前元素配对的元素，直接取下标返回</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, map.get(target - num)&#125;;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 否则将当前元素放入map</span><br>                map.put(num, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL之窗口函数</title>
    <link href="/2025/01/09/SQL%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    <url>/2025/01/09/SQL%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><blockquote><p>先说定义：「<strong>看完定义你可能觉得一头雾水，哈哈别急，等我后续一步步拆解</strong>」窗口函数是 SQL 中一种用于在查询结果集的特定 “窗口”（子集）上进行计算的函数。它能够在不改变原始数据行的基础上，为每行数据计算出一个聚合值或排名值等相关结果。与普通聚合函数（如 SUM、AVG 等）不同，聚合函数会将多行数据聚合成一行输出，而窗口函数可以在每一行数据上都返回一个计算结果。</p></blockquote><p><img src="/img/post/SQL%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0.assets/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E4%B8%8E%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="窗口函数与聚合函数的区别" title="窗口函数与聚合函数的区别"></p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">function</span>(args) <span class="hljs-keyword">OVER</span>([<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> expression] [<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> expression[<span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>]][frame])<br></code></pre></td></tr></table></figure><p>表达式拆解：</p><p>首先，OVER，PARTITION BY，ORDER BY 都是关键字，记住就好啦，之后越用越习惯，我们主要来拆解一下他们的作用</p><h4 id="1）function-args"><a href="#1）function-args" class="headerlink" title="1）function(args)"></a>1）<code>function(args)</code></h4><p>这个函数的作用就是在指定窗口中对数据进行计算或处理，以得出所需的结果。「至于这里说的窗口是什么，请往下看」</p><p><code>function(args)</code>可以是聚合函数，也可以是排名函数，具体使用什么函数就和不同的业务相关了，我在这里列出几个常用的函数：</p><p><strong>聚合函数</strong>：</p><ul><li><strong>SUM(args)</strong>：计算分区内指定列的总和。「这里的分区和窗口是一个概念，以下同理」</li><li><strong>AVG(args)</strong>：计算分区内指定列的平均值。</li><li><strong>MIN(args)</strong>：找出分区内指定列的最小值。</li><li><strong>MAX(args)</strong>：找出分区内指定列的最大值。</li></ul><p><strong>排名函数</strong>：</p><ul><li><strong>RANK()</strong>：为分区内的行分配排名，相同的值会获得相同的排名，并且会跳过相同排名的数量。</li><li><strong>DENSE_RANK()</strong>：为分区内的行分配排名，相同的值会获得相同的排名，但不会跳过相同排名的数量。</li><li><strong>ROW_NUMBER()</strong>：为分区内的行分配一个唯一的连续整数，从 1 开始，无论行内的值是否相同。（关于这三个排名函数的区别，下面会详细介绍➕做题练习）</li></ul><h4 id="2）-PARTITION-BY-expression"><a href="#2）-PARTITION-BY-expression" class="headerlink" title="2）[PARTITION BY expression]"></a>2）<code>[PARTITION BY expression]</code></h4><p><code>[PARTITION BY expression]</code>其中，PARTITION BY 是关键字，记住即可，而后面的 expression，就是我们要指定一个分组，这个字段通俗理解就是，我们要按照什么进行分组，当然他是<strong>可选的</strong></p><h4 id="3）-ORDER-BY-expression-ASC-DESC"><a href="#3）-ORDER-BY-expression-ASC-DESC" class="headerlink" title="3）[ORDER BY expression[ASC|DESC]]"></a>3）<code>[ORDER BY expression[ASC|DESC]]</code></h4><p>ORDER BY 就好理解了，就是要指定我们要按照什么进行排序，默认是升序，如果要降序排序，需要我们进行显示的指定</p><h4 id="4）-frame"><a href="#4）-frame" class="headerlink" title="4）[frame]"></a>4）<code>[frame]</code></h4><p>最后一部分就是这个<code>[frame]</code>了，他其实是指定一个窗口大小，也是可选的，其中他又分为两种模式，分别是<code>ROWS BETWEEN</code>和<code>RANGE BETWEEN</code>，下面我们来简单说一下这两种模式的区别：</p><p><code>ROWS BETWEEN</code>：按物理行来进行划分窗口，明确指定了窗口包含的行数，从当前行开始，向前或向后延伸一定的行数。</p><ul><li><code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>：窗口从分区的第一行开始，到当前行结束。</li><li><code>ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING</code>：窗口包含当前行的<strong>前一行、当前行和后一行</strong>，总共三行。</li></ul><p><code>RANGE BETWEEN</code>：按一定的数值逻辑来划分窗口范围，该范围是根据 <code>ORDER BY</code> 子句中列的值的范围来确定的，而不是物理行。通常与 <code>ORDER BY</code> 子句中的排序字段的逻辑值范围相关。</p><ul><li><code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>：窗口包含从分区的第一行开始，到当前行**（基于** <code>ORDER BY</code> **列的值）**的所有行。</li><li><code>RANGE BETWEEN 5 PRECEDING AND 5 FOLLOWING</code>：窗口包含 <code>ORDER BY</code> 列的值<strong>在当前行的值的前 5 个值到后 5 个值之间的所有行</strong>，而不是具体的物理行。</li></ul><p><strong>关键区别总结</strong>：</p><ul><li><code>ROWS BETWEEN</code> 基于<strong>物理行</strong>，根据实际的行位置来确定窗口范围，对于需要精确控制前后行数量的计算（如移动平均、相邻行对比等）很有用。</li><li><code>RANGE BETWEEN</code> 基于<strong>逻辑范围</strong>，根据 <code>ORDER BY</code> 列的<strong>值</strong>的范围来确定窗口范围，更适合处理需要根据排序字段的值的范围进行计算的情况，例如基于数据值范围的聚合计算，对数据的逻辑分组和分析更有帮助。</li></ul><p>大家注意体会上述的<strong>物理行</strong>与<strong>逻辑值</strong>的关系~~~</p><p>针对<code>[frame]</code>，我再列出一些他的常用表达式和对应的含义，大家可以对照着看看，一定可以理解~</p><p><code>ROWS BETWEEN</code> <strong>常用表达式</strong>：</p><ul><li><code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>：分区范围为从起始行到当前行</li><li><code>ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING</code>：分区范围为从当前行到最后一行</li><li><code>ROWS BETWEEN n PRECEDING AND m FOLLOWING</code>：从当前行的前 <code>n</code> 行开始，到当前行的后 <code>m</code> 行结束</li></ul><p><code>RANGE BETWEEN</code> <strong>常用表达式</strong>：</p><ul><li><code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>：此窗口范围从该分区中<strong>排序字段</strong>最小的行开始，到当前行结束。</li></ul><p><code>RANGE BETWEEN</code> <strong>的表达式不好理解，我们举一个具体的例子来看：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    product_id, <br>    sales_date, <br>    sales_amount, <br>    <span class="hljs-built_in">SUM</span>(sales_amount) <span class="hljs-keyword">OVER</span> (<br>        <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> product_id <br>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sales_date <br>        <span class="hljs-keyword">RANGE</span> <span class="hljs-keyword">BETWEEN</span> UNBOUNDED PRECEDING <span class="hljs-keyword">AND</span> <span class="hljs-keyword">CURRENT</span> <span class="hljs-type">ROW</span><br>    ) <span class="hljs-keyword">AS</span> cumulative_sales_amount<br><span class="hljs-keyword">FROM</span> <br>    sales;<br></code></pre></td></tr></table></figure><p><strong>解释</strong>：对于每个 <code>product_id</code> 分区，按 <code>sales_date</code> 排序。此窗口范围从该分区中 <code>sales_date</code> 最小的行开始，到当前行（根据 <code>sales_date</code> 的值）结束。<code>cumulative_sales_amount</code> 计算的是从该分区中 <code>sales_date</code> 最小的行到当前行的 <code>sales_amount</code> 的累计和。<strong>它会考虑</strong> <code>sales_date</code> <strong>值小于或等于当前行</strong> <code>sales_date</code> <strong>的所有行，而不是具体的行数。</strong></p><ul><li><code>RANGE BETWEEN n PRECEDING AND m FOLLOWING</code>：此窗口范围包括 <code>sales_date</code> 值在当前行 <code>sales_date</code> 减去 <code>n</code>（这里 <code>n = 10</code>）到当前行 <code>sales_date</code> 加上 <code>m</code>（这里 <code>m = 10</code>）范围内的所有行。</li></ul><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    product_id, <br>    sales_date, <br>    sales_amount, <br>    <span class="hljs-built_in">AVG</span>(sales_amount) <span class="hljs-keyword">OVER</span> (<br>        <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> product_id <br>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sales_date <br>        <span class="hljs-keyword">RANGE</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">10</span> PRECEDING <span class="hljs-keyword">AND</span> <span class="hljs-number">10</span> FOLLOWING<br>    ) <span class="hljs-keyword">AS</span> range_average<br></code></pre></td></tr></table></figure><p><strong>解释</strong>：对于每个 <code>product_id</code> 分区，按 <code>sales_date</code> 排序。此窗口范围包括 <code>sales_date</code> 值在当前行 <code>sales_date</code> 减去 <code>n</code>（这里 <code>n = 10</code>）到当前行 <code>sales_date</code> 加上 <code>m</code>（这里 <code>m = 10</code>）范围内的所有行。<code>range_average</code> 计算的是这些行的 <code>sales_amount</code> 的平均值。请注意，这里的范围是基于 <code>sales_date</code> 的值，而不是物理行，因此如果有多个行的 <code>sales_date</code> 在这个范围内，它们都会被考虑进去。</p><h3 id="排序函数的区别"><a href="#排序函数的区别" class="headerlink" title="排序函数的区别"></a>排序函数的区别</h3><p><img src="/img/post/SQL%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0.assets/1736386648048-781ff4fd-4d1a-44a8-a8ea-95cd9bca241a.jpeg" alt="三大排序函数的区别" title="三大排序函数的区别"></p><p><strong>函数记忆关键点：</strong></p><ul><li><code>row_number()</code>：序号不重复且连续</li><li><code>rank()</code>：序号可以重复，但序号不连续（比如：两个同学成绩都是 100 并列第一，第三个同学排名就是第三）</li><li><code>dense_rank()</code>：序号可以重复，序号连续</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>LeetCode <a href="https://leetcode.cn/problems/rank-scores/">178. 分数排名</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>  Scores.score,<br>  <span class="hljs-comment">-- 使用 DENSE_RANK() 窗口函数对成绩进行排名</span><br>  <span class="hljs-comment">-- 该函数会为结果集中的每一行分配一个排名，根据分数降序排列</span><br>  <span class="hljs-comment">-- 相同分数的行将获得相同的排名，并且排名不会跳过，即下一个不同分数的排名会紧挨着上一个不同分数的排名</span><br>  <span class="hljs-built_in">dense_rank</span>() <span class="hljs-keyword">over</span> (<br>    <span class="hljs-comment">-- 按照分数降序排列</span><br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>      score <span class="hljs-keyword">DESC</span><br>  ) <span class="hljs-keyword">AS</span> `rank`<br><span class="hljs-keyword">FROM</span><br>  Scores;<br></code></pre></td></tr></table></figure><p>LeetCode <a href="https://leetcode.cn/problems/department-highest-salary/">184. 部门工资最高的员工</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>  Department,<br>  Employee,<br>  Salary<br><span class="hljs-keyword">from</span><br>  (<br>    <span class="hljs-keyword">select</span><br>      d.name <span class="hljs-keyword">as</span> Department,<br>      e.name <span class="hljs-keyword">as</span> Employee,<br>      e.salary <span class="hljs-keyword">as</span> Salary,<br>      <span class="hljs-comment">-- 窗口函数，根据部门ID分组后再根据员工薪水降序排序的顺序进行排名</span><br>      <span class="hljs-built_in">rank</span>() <span class="hljs-keyword">over</span> (<br>        <span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span><br>          e.departmentId<br>        <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>          e.salary <span class="hljs-keyword">desc</span><br>      ) <span class="hljs-keyword">as</span> salary_rank<br>    <span class="hljs-keyword">from</span><br>      Employee <span class="hljs-keyword">as</span> e<br>      <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> Department <span class="hljs-keyword">as</span> d <span class="hljs-keyword">on</span> e.departmentId <span class="hljs-operator">=</span> d.id<br>  ) <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">where</span><br>  <span class="hljs-comment">-- 取排名为1的员工就是部门最高薪水的员工</span><br>  salary_rank <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看到这里，再来回看一下窗口函数的定义：</p><p>窗口函数是 SQL 中一种用于在查询结果集的特定 “窗口”（子集）上进行计算的函数。它能够在不改变原始数据行的基础上，为每行数据计算出一个聚合值或排名值等相关结果。与普通聚合函数（如 SUM、AVG 等）不同，聚合函数会将多行数据聚合成一行输出，而窗口函数可以在每一行数据上都返回一个计算结果。</p><p>已经很清晰啦~~</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
      <tag>窗口函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2025/01/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>偷个懒先传个PDF上来 ~~ 有需要可以下载下来看</p></blockquote><div class="row">    <embed src="/pdf/排序算法.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>十大排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HelloWorld ~</title>
    <link href="/2025/01/07/hello-world/"/>
    <url>/2025/01/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>都和你说了什么都没有，真的什么都没有</p>]]></content>
    
    
    <categories>
      
      <category>博文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>我的第一篇博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
