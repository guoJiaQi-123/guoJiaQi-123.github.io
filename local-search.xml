<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>015.轮转数组</title>
    <link href="/2025/02/21/015-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <url>/2025/02/21/015-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<hr><p>title: 012.最小覆盖子串<br>date: 2025-02-15 22:54:07<br>author: Ovo-<br>tags:</p><ul><li>算法</li><li>刷题<br>categories:</li><li>hot100算法<br>excerpt: 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<br>banner_img: &#x2F;img&#x2F;bg&#x2F;你的名字.jpg<br>index_img: &#x2F;img&#x2F;page&#x2F;最小覆盖子串.png</li></ul><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>014.合并区间</title>
    <link href="/2025/02/21/014-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <url>/2025/02/21/014-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<hr><p>title: 012.最小覆盖子串<br>date: 2025-02-15 22:54:07<br>author: Ovo-<br>tags:</p><ul><li>算法</li><li>刷题<br>categories:</li><li>hot100算法<br>excerpt: 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<br>banner_img: &#x2F;img&#x2F;bg&#x2F;你的名字.jpg<br>index_img: &#x2F;img&#x2F;page&#x2F;最小覆盖子串.png</li></ul><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>013.最大子数组和</title>
    <link href="/2025/02/21/013-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <url>/2025/02/21/013-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<hr><p>title: 012.最小覆盖子串<br>date: 2025-02-15 22:54:07<br>author: Ovo-<br>tags:</p><ul><li>算法</li><li>刷题<br>categories:</li><li>hot100算法<br>excerpt: 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。<br>banner_img: &#x2F;img&#x2F;bg&#x2F;你的名字.jpg<br>index_img: &#x2F;img&#x2F;page&#x2F;最小覆盖子串.png</li></ul><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>017.缺失的第一个正数</title>
    <link href="/2025/02/21/017-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <url>/2025/02/21/017-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></h1><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,0]</span><br>输出：3<br>解释：范围 <span class="hljs-comment">[1,2]</span> 中的数字都在数组中。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [3,4,-1,1]</span><br><span class="hljs-string">输出：2</span><br><span class="hljs-string">解释：1 在数组中，但 2 没有。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,8,9,11,12]</span><br>输出：<span class="hljs-number">1</span><br>解释：最小的正数 <span class="hljs-number">1</span> 没有出现。<br></code></pre></td></tr></table></figure><p><strong>提示</strong>：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>由于题目要求我们**「只能使用常数级别的空间」**，而要找的数一定在[1, N + 1]左闭右闭（这里N是数组的长度）这个区间里。因此，我们可以就把原始的数组当做哈希表来使用。事实上，哈希表其实本身也是一个数组；</p><p>我们要找的数就在[1, N + 1]里，最后N + 1这个元素我们不用找。因为在前面的N个元素都找不到的情况下，我们才返回N + 1；</p><p>那么，我们可以采取这样的思路：就<strong>把1这个数放到下标为0的位置，2这个数放到下标为1的位置</strong>，按照这种思路整理一遍数组。然后我们再遍历一次数组，第1个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。</p><p>这个思想就相当于我们自己编写哈希函数，这个哈希函数的规则特别简单，那就是数值为i的数映射到下标为i - 1的位置。</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="/img/post/017-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/41%E5%9B%BE%E8%A7%A3.png"><br><img src="/img/post/017-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/41%E5%9B%BE%E8%A7%A3.gif"></p><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  时间复杂度高</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = Arrays.stream(nums).distinct().filter(x -&gt; x &gt; <span class="hljs-number">0</span>).sorted().toArray();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (array[i] - <span class="hljs-number">1</span> != i) &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> array.length + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 和上面的思想一样，希望将 1放到0索引处，2放到1索引处，依次类推</span><br><span class="hljs-comment">// 使用了这原数组上交换元素的方法，时间复杂度和空间复杂度都低</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  时间复杂度，空间复杂度都低</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstMissingPositive2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 如果遍历到3，我就希望把他放到索引2处，即swap(nums, i, nums[i] - 1);</span><br>        <span class="hljs-comment">// 这里i索引处的值nums[i]=3,交换他和 nums[i]-1「2」处的值，3就到了2索引处</span><br>        <span class="hljs-comment">// 前提是 nums[nums[i] - 1] != nums[i]</span><br>        <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= nums.length &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;<br>            swap(nums, i, nums[i] - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果不是0索引处为1，则缺的就是1，依次类推</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] - <span class="hljs-number">1</span> != i) &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.length + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = t;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>016.除自身以外数组的乘积</title>
    <link href="/2025/02/21/016-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"/>
    <url>/2025/02/21/016-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h1><p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请 <strong>不要使用除法</strong>，且在 <code>O(n)</code> 时间复杂度内完成此题。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: nums = [<span class="hljs-number">1,2,3,4</span>]<br>输出: [<span class="hljs-number">24,12,8,6</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[-1,1,0,-3,3]</span><br>输出: <span class="hljs-comment">[0,0,9,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li>输入 <strong>保证</strong> 数组 <code>answer[i]</code> 在 <strong>32 位</strong> 整数范围内</li></ul><p><strong>进阶</strong>：你可以在 <code>O(1)</code> 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 <strong>不被视为</strong> 额外空间。）</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><h2 id="左右乘积列表"><a href="#左右乘积列表" class="headerlink" title="左右乘积列表"></a>左右乘积列表</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们不必将所有数字的乘积除以给定索引处的数字得到相应的答案，而是<strong>利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。</strong></p><p>对于给定索引 i，我们将使用它<strong>左边所有数字的乘积</strong>乘以<strong>右边所有数字的乘积</strong>。下面让我们更加具体的描述这个算法。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>初始化两个空数组 left 和 right。对于给定索引 i ，left[i]代表的是 i 左侧所有数字的乘积，right[i]代表的是 i 右侧所有数字的乘积。</p><p>我们需要用两个循环来填充 left 和 right 数组的值。对于数组 left，left[0]应该是 1，因为第一个元素的左边没有元素。对于其他元素：left[i] &#x3D; left[i-1] * nums[i-1]。</p><p>同理，对于数组 right，right[length-1]应为 1。length 指的是输入数组的大小。其他元素：right[i] &#x3D;right[i+1] * nums [i+1]。</p><p>当 right 和 left 数组填充完成，我们只需要在输入数组上迭代，且索引 i 处的值为：left[i] * right[i]。</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="/img/post/016-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF.assets/238.gif"></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>尽管上面的方法已经能够很好的解决这个问题，但是空间复杂度并不为常数。</p><p>由于输出数组不算在空间复杂度内，那么我们可以将 left 或 right 数组用输出数组来计算。先把输出数组当作 left 数组来计算，然后再动态构造 right 数组得到结果。让我们来看看基于这个思想的算法。</p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>初始化 left 数组，对于给定索引 i，left[i]代表的是 i 左侧所有数字的乘积。</p><p>构造方式与之前相同，只是我们试图节省空间，先把 left 作为方法一的 leftL 数组。</p><p>这种方法的唯一变化就是我们没有构造 right 数组。而是用一个遍历来跟踪右边元素的乘积。并更新数组 left[i]&#x3D;left[i]∗right。然后 right 更新为 right&#x3D;right∗nums[i]，其中变量 right 表示的就是索引右侧数字的乘积。</p><h1 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * O（n）时间复杂度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-comment">// left数组用于存储当前下标左侧数的积</span><br>    <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-comment">// right 数组用于存储当前下标右侧数的积</span><br>    <span class="hljs-type">int</span>[] right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    left[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    right[nums.length - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        left[i] = left[i - <span class="hljs-number">1</span>] * nums[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        right[i] = right[i + <span class="hljs-number">1</span>] * nums[i + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        nums[i] = left[i] * right[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * O（1）时间复杂度</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] productExceptSelf2(<span class="hljs-type">int</span>[] nums) &#123;<br>    <span class="hljs-type">int</span>[] left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    left[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 在left数组中记录每个下标处左侧值的积 nums：[1,2,3,4]  left：[1,1,2,6]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; left.length; i++) &#123;<br>        left[i] = left[i - <span class="hljs-number">1</span>] * nums[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// 从右往左遍历left数组，并且使用变量right记录当前下标右侧值的积</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 最终的结构 = 左侧数的积 * 右侧数的积</span><br>        left[i] = left[i] * right;<br>        <span class="hljs-comment">// 计算下个下标右侧数的积</span><br>        right *= nums[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>012.最小覆盖子串</title>
    <link href="/2025/02/15/012-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <url>/2025/02/15/012-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h1><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code><br>所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span><span class="hljs-punctuation">,</span> t <span class="hljs-punctuation">=</span> <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span><br>解释：最小覆盖子串 <span class="hljs-string">&quot;BANC&quot;</span> 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">&quot;a&quot;</span><br>解释：整个字符串 s 是最小覆盖子串。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入<span class="hljs-symbol">:</span> s = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;aa&quot;</span><br>输出<span class="hljs-symbol">:</span> <span class="hljs-string">&quot;&quot;</span><br>解释<span class="hljs-symbol">:</span> <span class="hljs-built_in">t</span> 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p><strong>进阶</strong>：你能设计一个在 <code>o(m+n)</code> 时间内解决此问题的算法吗？</p><h1 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h1><p>这道题同样适用<strong>滑动窗口</strong><br>思路，我们想要原始串中找到最小的子串可以覆盖目标串，我们可以先移动窗口的终止位置，直到找到一个覆盖目标串的子串后，再向右移动窗口的起始位置（缩小窗口的大小，看缩小后是否仍然满足覆盖目标串）。</p><p>这里需要注意的是，如何判断原始串是否覆盖目标串，<strong>我们先统计目标串需要各种字符个数</strong>， <strong>统计原始串 i~j 范围各种字符个数</strong><br>，如果在这个范围内，<strong>目标串需要的字符个数恰好等于原始串i~j 范围各种字符个数</strong>，则说明已经覆盖目标串。</p><p>解题步骤如下：</p><ol><li>统计目标串需要各种字符个数， 统计原始串 i~j 范围各种字符个数</li><li>如果原始串 i~j 范围内不满足条件，j++ 扩大范围，直到满足条件 j 停下来</li><li>一旦满足条件 i++ 缩小范围，直到再次不满足条件 …</li><li>重复 2. 3. 两步直至 j 到达原始串末尾</li></ol><h2 id="图解步骤"><a href="#图解步骤" class="headerlink" title="图解步骤"></a>图解步骤</h2><p><img src="/img/post/012-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.assets/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.gif"></p><h1 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> OldGj 2025/2/15</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@apiNote</span> 76. 最小覆盖子串</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_012_minWindow</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 封装窗口起始位置和终止位置的静态类</span><br><span class="hljs-comment">     * 在方法返回值时，可以使用起始位置和终止位置截取字符串进行返回</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>        <span class="hljs-type">int</span> left;<br>        <span class="hljs-type">int</span> right;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Result</span><span class="hljs-params">(Integer left, Integer right)</span> &#123;<br>            <span class="hljs-built_in">this</span>.left = left;<br>            <span class="hljs-built_in">this</span>.right = right;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        <span class="hljs-type">char</span>[] sourceArr = s.toCharArray(); <span class="hljs-comment">// 原始串</span><br>        <span class="hljs-type">int</span>[] sourceCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br><br>        <span class="hljs-type">char</span>[] targetArr = t.toCharArray(); <span class="hljs-comment">// 目标串</span><br>        <span class="hljs-type">int</span>[] targetCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : targetArr) &#123;<br>            targetCount[c]++; <span class="hljs-comment">// 目标串中一个字符出现了几次</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 需要满足多少个条件</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : targetCount) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 将一个字符看做一个条件，目标串中有多少种字符就有多少条件</span><br>                count++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">counted</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 已经满足的条件</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的起始位置 left</span><br>        <span class="hljs-type">Result</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; right &lt; sourceArr.length; right++) &#123; <span class="hljs-comment">// 滑动窗口的终止位置right</span><br>            <span class="hljs-type">char</span> <span class="hljs-variable">rightCh</span> <span class="hljs-operator">=</span> sourceArr[right];<br>            <span class="hljs-comment">// 统计原始串 left~right 范围各种字符的个数</span><br>            sourceCount[rightCh]++;<br>            <span class="hljs-comment">// 如果原始串中字符出现的次数等于目标串中字符出现的次数</span><br>            <span class="hljs-keyword">if</span> (sourceCount[rightCh] == targetCount[rightCh]) &#123;<br>                counted++; <span class="hljs-comment">// 每满足一个条件，counted++</span><br>            &#125;<br>            <span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; counted == count) &#123; <span class="hljs-comment">// 当前窗口满足所有条件后，尝试缩小窗口</span><br>                <span class="hljs-comment">// 找所有满足条件的解中，长度最小的</span><br>                <span class="hljs-keyword">if</span> (res == <span class="hljs-literal">null</span>) &#123;<br>                    res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(left, right);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> ((right - left) &lt; (res.right - res.left)) &#123;<br>                        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(left, right);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 开始移动left，找长度更小的解</span><br>                <span class="hljs-type">char</span> <span class="hljs-variable">leftCh</span> <span class="hljs-operator">=</span> sourceArr[left];<br>                sourceCount[leftCh]--;<br>                <span class="hljs-comment">// 如果原始串中字符出现的次数小于了目标串中字符出现的此时，将counted--</span><br>                <span class="hljs-keyword">if</span> (sourceCount[leftCh] &lt; targetCount[leftCh]) &#123;<br>                    counted--;<br>                &#125;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;&quot;</span> : <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(sourceArr, res.left, res.right - res.left + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java热部署插件JRebel</title>
    <link href="/2025/02/14/Java%E7%83%AD%E9%83%A8%E7%BD%B2%E6%8F%92%E4%BB%B6JRebel/"/>
    <url>/2025/02/14/Java%E7%83%AD%E9%83%A8%E7%BD%B2%E6%8F%92%E4%BB%B6JRebel/</url>
    
    <content type="html"><![CDATA[<h2 id="JRebel"><a href="#JRebel" class="headerlink" title="JRebel"></a>JRebel</h2><p>官方文档：<a href="https://www.jrebel.com/">https://www.jrebel.com/</a></p><h3 id="什么是JRebel"><a href="#什么是JRebel" class="headerlink" title="什么是JRebel"></a>什么是JRebel</h3><div class="note note-primary">            <p>JRebel 是国外团队开发的一款收费工具，JRebel 允许开发团队在有限的时间内完成更多的任务修正更多的问题，发布更高质量的软件产品，JRebel 可快速实现热部署，节省了大量重启时间，提高了个人开发效率。JRebel 是一款 JAVA 虚拟机插件，它使得 Java 程序员能在不进行重部署的情况下，即时看到代码的改变对一个应用程序带来的影响。</p>          </div><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在庞大的项目，我们启动项目的时间较长，尤其每次修改完代码要进行测试，就要重新编译启动项目，耗时且繁琐，热部署插件通过设置更新操作，就可以实现快速启动项目，开发效率显著提高。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>需要安装JRebel</li></ol><p><img src="/img/post/Java%E7%83%AD%E9%83%A8%E7%BD%B2%E6%8F%92%E4%BB%B6JRebel.assets/1739526765527-53252d0e-61f1-47a8-af4e-089225792274.png" alt="img"></p><ol start="2"><li>激活插件</li></ol><p>最新激活地址<code>http://42.193.18.168:8088/5a3f317c-3de0-4676-9b20-9c16cec17d90</code></p><p>如果激活过期, 可以重新生成GUID , 替换原来的GUID即可。</p><p>在线生成GUID：<a href="https://www.guidgen.com/">https://www.guidgen.com/</a></p><p>在下面的框中输入激活的url地址，后续可能会失效！！！</p><p><img src="/img/post/Java%E7%83%AD%E9%83%A8%E7%BD%B2%E6%8F%92%E4%BB%B6JRebel.assets/1739526795772-aa99b716-c4b7-4cb0-9241-59ef495079cf.png" alt="img"></p><ol start="3"><li>设置离线使用</li></ol><p>JRebel激活之后默认是联网的 , 在该模式下 , JRebel会一直联网监测激活信息 ，所以需要设置离线使用。</p><p><img src="/img/post/Java%E7%83%AD%E9%83%A8%E7%BD%B2%E6%8F%92%E4%BB%B6JRebel.assets/1739526877581-9bd97875-f74e-4678-9ecf-7b4671a38994.png" alt="img"></p><ol start="4"><li>设置更新编译项目</li></ol><p><img src="/img/post/Java%E7%83%AD%E9%83%A8%E7%BD%B2%E6%8F%92%E4%BB%B6JRebel.assets/1739526889810-f5bd6276-e5ea-4708-8b88-088a6f553a81.png" alt="img"></p><ol start="5"><li>设置完之后重新启动IDEA</li></ol><p><img src="/img/post/Java%E7%83%AD%E9%83%A8%E7%BD%B2%E6%8F%92%E4%BB%B6JRebel.assets/1739526934446-c23a513b-e26f-4568-bd34-d42a63972b56.png" alt="img"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上设置，就可以实现项目的热部署以及快速编译，大大提高开发效率。 </p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具分享</tag>
      
      <tag>热部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2025/01/27/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/01/27/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h1><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><h3 id="文件的组织"><a href="#文件的组织" class="headerlink" title="文件的组织"></a>文件的组织</h3><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20250127201057977.png" alt="image-20250127201057977"></p><h3 id="查看路径"><a href="#查看路径" class="headerlink" title="查看路径"></a>查看路径</h3><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>显示当前目录的路径</p><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20250127201344258.png" alt="查看路径"></p><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>查看命令的可执行文件所在路径， <code>Linux</code> 下，每一条命令其实都对应一个可执行程序，在终端中输入命令，按回车的时候，就是执行了对应的那个程序， <code>which</code> 命令本身对应的程序也存在于 <code>Linux</code> 中。</p><p>总的来说一个命令就是一个可执行程序。</p><p>例如我的Ubuntu服务器中安装了MySQL，我想要查看MySQL的mysql命令的路径，则可以使用下面的方式：</p><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20250127201555803.png" alt="which"></p><h3 id="浏览和切换目录"><a href="#浏览和切换目录" class="headerlink" title="浏览和切换目录"></a>浏览和切换目录</h3><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>列出文件和目录，它是 <code>Linux</code> 最常用的命令之一。</p><p>【常用参数】</p><ul><li><p><code>-a</code> 显示所有文件和目录包括隐藏的</p></li><li><p><code>-l</code> 显示详细列表</p></li><li><p><code>-h</code> 适合人类阅读的</p></li><li><p><code>-t</code> 按文件最近一次修改时间排序</p></li><li><p><code>-i</code> 显示文件的 <code>inode</code> （ <code>inode</code> 是文件内容的标识）</p></li></ul><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20250127201826028.png" alt="ls命令"></p><p><code>ls -l</code>命令用于显示当前目录下的文件详细信息，等同于<code>ll</code>命令</p><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20250127202002946.png" alt="ll命令"></p><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p><code>cd</code> 是英语 <code>change directory</code> 的缩写，表示切换目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd / --&gt; 跳转到根目录<br>cd ~ --&gt; 跳转到家目录<br>cd .. --&gt; 跳转到上级目录<br>cd ./home --&gt; 跳转到当前目录的home目录下<br>cd /home/lion --&gt; 跳转到根目录下的home目录下的lion目录<br>cd --&gt; 不添加任何参数，也是回到家目录<br><br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>「 注意 」 输入cd &#x2F;ho + 单次 tab 键会自动补全路径 + 两次 tab 键会列出所有可能的目录列表。</p>          </div><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>列举目录大小信息。</p><p>【常用参数】</p><ul><li><p><code>-h</code> 适合人类阅读的；</p></li><li><p><code>-a</code> 同时列举出目录下文件的大小信息；</p></li><li><p><code>-s</code> 只显示总计大小，不显示具体信息。</p></li></ul><h3 id="浏览和创建文件"><a href="#浏览和创建文件" class="headerlink" title="浏览和创建文件"></a>浏览和创建文件</h3><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>一次性显示文件所有内容，更适合查看小的文件。</p><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20250127202551354.png" alt="image-20250127202551354"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat demo<br></code></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-n</code> 显示行号。</li></ul><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20250127202843807.png" alt="image-20250127202843807"></p><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>分页显示文件内容，更适合查看大的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">less cloud-init.log<br></code></pre></td></tr></table></figure><p>【快捷操作】</p><ul><li><p>空格键：前进一页（一个屏幕）；</p></li><li><p><code>b</code> 键：后退一页；</p></li><li><p>回车键：前进一行；</p></li><li><p><code>y</code> 键：后退一行；</p></li><li><p>上下键：回退或前进一行；</p></li><li><p><code>d</code> 键：前进半页；</p></li><li><p><code>u</code> 键：后退半页；</p></li><li><p><code>q</code> 键：停止读取文件，中止 <code>less</code> 命令；</p></li><li><p><code>=</code> 键：显示当前页面的内容是文件中的第几行到第几行以及一些其它关于本页内容的详细信息；</p></li><li><p><code>h</code> 键：显示帮助文档；</p></li><li><p><code>/</code> 键：进入搜索模式后，按 <code>n</code> 键跳到一个符合项目，按 <code>N</code> 键跳到上一个符合项目，同时也可以输入正则表达式匹配。</p></li></ul><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>显示文件的开头几行（默认是 10 行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">head cloud-init.log<br></code></pre></td></tr></table></figure><p>【参数】</p><ul><li><code>-n</code> 指定行数 <code>head cloud-init.log -n 2</code></li></ul><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20250127203032927.png" alt="image-20250127203032927"></p><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><p>显示文件的结尾几行（默认是 10 行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tail cloud-init.log<br></code></pre></td></tr></table></figure><p>【参数】</p><ul><li><p><code>-n</code> 指定行数 <code>tail cloud-init.log -n 2</code></p></li><li><p><code>-f</code> 会每过 1 秒检查下文件是否有更新内容，也可以用 <code>-s</code> 参数指定间隔时间 <code>tail -f -s 4 xxx.log</code></p></li></ul><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20250127203107680.png" alt="image-20250127203107680"></p><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>创建一个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch new_file<br></code></pre></td></tr></table></figure><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>创建一个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir new_folder<br></code></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-p</code> 递归的创建目录结构 <code>mkdir -p one/two/three</code></li></ul><h3 id="文件的复制和移动"><a href="#文件的复制和移动" class="headerlink" title="文件的复制和移动"></a>文件的复制和移动</h3><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>拷贝文件和目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp file file_copy --&gt; file 是目标文件，file_copy 是拷贝出来的文件<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp file one --&gt; 把 file 文件拷贝到 one 目录下，并且文件名依然为 file<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp file one/file_copy --&gt; 把 file 文件拷贝到 one 目录下，文件名为file_copy<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp *.txt folder --&gt; 把当前目录下所有 txt 文件拷贝到 folder 目录下<br></code></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-r</code> 递归的拷贝，常用来拷贝一整个目录</li></ul><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>移动（<strong>重命名</strong>）文件或目录，与 cp 命令用法相似。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv file one --&gt; 将 file 文件移动到 one 目录下<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv new_folder one --&gt; 将 new_folder 文件夹移动到one目录下<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv *.txt folder --&gt; 把当前目录下所有 txt 文件移动到 folder 目录下<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv file new_file --&gt; file 文件重命名为 new_file<br></code></pre></td></tr></table></figure><h3 id="文件的删除和链接"><a href="#文件的删除和链接" class="headerlink" title="文件的删除和链接"></a>文件的删除和链接</h3><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>删除文件和目录，由于 <code>Linux</code> 下没有回收站，一旦删除非常难恢复，因此<span class="label label-danger"> 需要谨慎操作</span></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm new_file  --&gt; 删除 new_file 文件<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm f1 f2 f3  --&gt; 同时删除 f1 f2 f3 3个文件<br></code></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><p><code>-i</code> 向用户确认是否删除；</p></li><li><p><code>-f</code> 文件强制删除；<span class="label label-danger"> 需要谨慎操作</span></p></li><li><p><code>-r</code> 递归删除文件夹，著名的删除操作 <code>rm -rf</code> 。<span class="label label-danger"> 需要谨慎操作</span></p></li></ul><h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p>英文 <code>Link</code> 的缩写，表示创建链接。</p><p>学习创建链接之前，首先要理解链接是什么，我们先来看看 <code>Linux</code> 的文件是如何存储的：</p><p><code>Linux</code> 文件的存储方式分为 3 个部分，<strong>文件名</strong>、<strong>文件内容</strong>以及<strong>权限</strong>，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 <code>inode</code> 标识绑定到文件内容。</p><p>Linux 下有两种链接类型：<strong>硬链接</strong>和<strong>软链接</strong>。</p><h5 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h5><p>使链接的两个文件共享同样文件内容，就是同样的 <code>inode</code> ，一旦文件 1 和文件 2 之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，只能创建指向文件的硬链接，不能创建指向目录的（其实也可以，但比较复杂）而软链接都可以，因此软链接使用更加广泛。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln file1 file2  --&gt; 创建 file2 为 file1 的硬链接<br></code></pre></td></tr></table></figure><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/640.jpeg" alt="null"></p><p>如果我们用 <code>rm file1</code> 来删除 <code>file1</code> ，对 <code>file2</code> 没有什么影响，对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除。只有同时删除了 <code>file1</code> 与<code>file2</code> 后，它们共同指向的文件内容才会消失。</p><h5 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h5><p>软链接就类似 <code>windows</code> 下快捷方式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s file1 file2<br></code></pre></td></tr></table></figure><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/640-1737981427872-1.jpeg" alt="null"></p><p>执行 <code>ls -l</code> 命名查看当前目录下文件的具体信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">total 0<br>-rw-r--r-- 1 root root 0 Jan 14 06:29 file1<br>lrwxrwxrwx 1 root root 5 Jan 14 06:42 file2 -&gt; file1  # 表示file2 指向 file1<br></code></pre></td></tr></table></figure><p>其实 <code>file2</code> 只是 <code>file1</code> 的一个快捷方式，它指向的是 <code>file1</code> ，所以显示的是 <code>file1</code> 的内容，但其实 <code>file2</code> 的 <code>inode</code> 与 <code>file1</code> 并不相同。如果我们删除了 <code>file2</code> 的话， <code>file1</code>是不会受影响的，但如果删除 <code>file1</code> 的话， <code>file2</code> 就会变成死链接，因为指向的文件不见了。</p><p>在Linux中，文件链接方式主要有两种：**硬链接（Hard Link）**和**符号链接（Symbolic Link，也叫软链接）**。它们都用于在文件系统中创建文件的引用，允许用户通过多个路径访问同一个文件。</p><p>来看看chatGPT对硬链接和软链接的解释：</p><ol><li>硬链接（Hard Link）</li></ol><p>硬链接是指在文件系统中<strong>为同一个文件创建一个新的目录项</strong>。硬链接和原始文件都是对同一数据块（inode）进行引用，硬链接与原始文件共享相同的inode号，所以它们是完全等同的。</p><ul><li><p><strong>特点：</strong></p><ul><li>硬链接指向同一个数据块，删除任何一个链接（包括原始文件）都不会影响另一个链接，只要有一个硬链接存在，文件的数据内容就不会被删除。</li><li>无法跨文件系统创建硬链接（即硬链接必须在同一个文件系统内）。</li><li>不支持目录（为了避免循环引用，除非是超级用户）。</li></ul></li><li><p><strong>命令：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> &lt;原始文件&gt; &lt;硬链接名称&gt;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> file.txt link_to_file.txt<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>符号链接（Symbolic Link，软链接）</li></ol><p>符号链接是指一个文件包含指向另一个文件路径的特殊文件，它类似于Windows中的<strong>快捷方式</strong>。符号链接本质上是一个文本文件，保存着原始文件的路径。</p><ul><li><p><strong>特点：</strong></p><ul><li>符号链接包含对目标文件路径的引用，删除符号链接文件时不会影响原始文件，符号链接指向的文件如果被删除或移动，符号链接将变成“悬挂”的状态（即指向一个不存在的文件）。</li><li>可以跨文件系统创建符号链接。</li><li>符号链接可以指向目录或文件。</li></ul></li><li><p><strong>命令：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -s &lt;原始文件&gt; &lt;符号链接名称&gt;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -s /path/to/file.txt link_to_file.txt<br></code></pre></td></tr></table></figure></li></ul><p>总结：</p><ul><li><strong>硬链接</strong>：文件之间完全等同，操作系统看不到不同，删除一个不会影响另一个，无法跨文件系统，不能链接目录。</li><li><strong>符号链接</strong>：文件之间有路径引用关系，符号链接可以跨文件系统并可以链接目录，但如果原始文件被删除，符号链接会失效。</li></ul><h2 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h2><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/640-1737982969745-6.jpeg" alt="null"></p><p>自己创建的用户是有限权限的用户，这样大大提高了 <code>Linux</code> 系统的安全性，有效防止误操作或是病毒攻击，但是我们执行的某些命令需要更高权限时可以使用 <code>sudo</code> 命令。</p><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>以 <code>root</code> 身份运行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo date  --&gt; 当然查看日期是不需要sudo的这里只是演示，sudo 完之后一般还需要输入用户密码的<br></code></pre></td></tr></table></figure><h4 id="useradd-passwd"><a href="#useradd-passwd" class="headerlink" title="useradd + passwd"></a>useradd + passwd</h4><ul><li><p><code>useradd</code> 添加新用户</p></li><li><p><code>passwd</code> 修改用户密码</p></li></ul><p>这两个命令需要 <code>root</code> 用户权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd lion --&gt; 添加一个lion用户，添加完之后在 /home 路径下可以查看<br>passwd lion --&gt; 修改lion用户的密码<br></code></pre></td></tr></table></figure><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>删除用户，需要 <code>root</code> 用户权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">userdel lion --&gt; 只会删除用户名，不会从/home中删除对应文件夹<br>userdel lion -r --&gt; 会同时删除/home下的对应文件夹<br></code></pre></td></tr></table></figure><h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p>切换用户，需要 <code>root</code> 用户权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo su --&gt; 切换为root用户（exit 命令或 CTRL + D 快捷键都可以使普通用户切换为 root 用户）<br>su lion --&gt; 切换为普通用户<br>su - --&gt; 切换为root用户<br></code></pre></td></tr></table></figure><h3 id="群组的管理"><a href="#群组的管理" class="headerlink" title="群组的管理"></a>群组的管理</h3><p><code>Linux</code> 中每个用户都属于一个特定的群组，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。</p><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><p>创建群组，用法和 <code>useradd</code> 类似。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd friends<br></code></pre></td></tr></table></figure><h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><p>删除一个已存在的群组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupdel foo  --&gt; 删除foo群组<br></code></pre></td></tr></table></figure><h4 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h4><p>查看用户所在群组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groups lion  --&gt; 查看 lion 用户所在的群组<br></code></pre></td></tr></table></figure><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p>用于修改用户的账户。</p><p>【常用参数】</p><ul><li><p><code>-l</code> 对用户重命名。需要注意的是 <code>/home</code> 中的用户家目录的名字不会改变，需要手动修改。</p></li><li><p><code>-g</code> 修改用户所在的群组，例如 <code>usermod -g friends lion</code>修改 <code>lion</code> 用户的群组为 <code>friends</code> 。</p></li><li><p><code>-G</code> 一次性让用户添加多个群组，例如 <code>usermod -G friends,foo,bar lion</code> 。</p></li><li><p><code>-a</code> <code>-G</code> 会让你离开原先的群组，如果你不想这样做的话，就得再添加 <code>-a</code> 参数，意味着<code>append</code> 追加的意思。</p></li></ul><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><p>用于修改文件的群组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp bar file.txt --&gt; file.txt文件的群组修改为bar<br></code></pre></td></tr></table></figure><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>改变文件的所有者，需要 <code>root</code> 身份才能运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown lion file.txt --&gt; 把其它用户创建的file.txt转让给lion用户<br>chown lion:bar file.txt --&gt; 把file.txt的用户改为lion，群组改为bar<br></code></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-R</code> 递归设置子目录和子文件， <code>chown -R lion:lion /home/frank</code> 把 <code>frank</code> 文件夹的用户和群组都改为 <code>lion</code> 。</li></ul><h3 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h3><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p>修改访问权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 740 file.txt<br></code></pre></td></tr></table></figure><p>【常用参数】</p><ul><li><code>-R</code> 可以递归地修改文件访问权限，例如 <code>chmod -R 777 /home/lion</code></li></ul><p>修改权限的确简单，但是理解其深层次的意义才是更加重要的。下面我们来系统的学习<code>Linux</code> 的文件权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@lion ~]# ls -l<br>drwxr-xr-x 5 root root 4096 Apr 13  2020 climb # 目录<br>lrwxrwxrwx 1 root root    7 Jan 14 06:41 hello2.c -&gt; hello.c # 链接<br>-rw-r--r-- 1 root root  149 Jan 13 06:14 hello.c # 普通文件<br></code></pre></td></tr></table></figure><p>其中 <code>drwxr-xr-x</code> 表示文件或目录的权限。让我们一起来解读它具体代表什么？</p><ul><li><p><code>d</code> ：表示目录，就是说这是一个目录，普通文件是 <code>-</code> ，链接是 <code>l</code> 。</p></li><li><p><code>r</code> ：<code>read</code> 表示文件可读。</p></li><li><p><code>w</code> ：<code>write</code> 表示文件可写，一般有写的权限，就有删除的权限。</p></li><li><p><code>x</code> ：<code>execute</code> 表示文件可执行。</p></li><li><p><code>-</code> ：表示没有相应权限。</p></li></ul><p>权限的整体是按用户来划分的，如下图所示：</p><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/640-1737982969745-7.jpeg" alt="null"></p><p>现在再来理解这句权限 <code>drwxr-xr-x</code> 的意思：</p><ul><li><p>它是一个文件夹；</p></li><li><p>它的所有者具有：读、写、执行权限；</p></li><li><p>它的群组用户具有：读、执行的权限，没有写的权限；</p></li><li><p>它的其它用户具有：读、执行的权限，没有写的权限。</p></li></ul><p>现在理解了权限，我们使用 <code>chmod</code> 来尝试修改权限。<code>chmod</code> 它不需要是 <code>root</code> 用户才能运行的，只要你是此文件所有者，就可以用 <code>chmod</code> 来修改文件的访问权限。</p><h5 id="数字分配权限"><a href="#数字分配权限" class="headerlink" title="数字分配权限"></a>数字分配权限</h5><table><thead><tr><th>权限</th><th>数字</th></tr></thead><tbody><tr><td>r</td><td>4</td></tr><tr><td>w</td><td>2</td></tr><tr><td>x</td><td>1</td></tr></tbody></table><p>因此要改变权限，只要做一些简单的加法就行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 640 hello.c <br><span class="hljs-meta prompt_"># </span><span class="language-bash">6 = 4 + 2 + 0 表示所有者具有 rw 权限</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">4 = 4 + 0 + 0 表示群组用户具有 r 权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">0 = 0 + 0 + 0 表示其它用户没有权限</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对应文字权限为：-rw-r-----</span><br></code></pre></td></tr></table></figure><h5 id="用字母来分配权限"><a href="#用字母来分配权限" class="headerlink" title="用字母来分配权限"></a>用字母来分配权限</h5><ul><li><p><code>u</code> ：<code>user</code> 的缩写，用户的意思，表示所有者。</p></li><li><p><code>g</code> ：<code>group</code> 的缩写，群组的意思，表示群组用户。</p></li><li><p><code>o</code> ：<code>other</code> 的缩写，其它的意思，表示其它用户。</p></li><li><p><code>a</code> ：<code>all</code> 的缩写，所有的意思，表示所有用户。</p></li><li><p><code>+</code> ：加号，表示添加权限。</p></li><li><p><code>-</code> ：减号，表示去除权限。</p></li><li><p><code>=</code> ：等于号，表示分配权限。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u+rx file --&gt; 文件file的所有者增加读和运行的权限<br>chmod g+r file --&gt; 文件file的群组用户增加读的权限<br>chmod o-r file --&gt; 文件file的其它用户移除读的权限<br>chmod g+r o-r file --&gt; 文件file的群组用户增加读的权限，其它用户移除读的权限<br>chmod go-r file --&gt; 文件file的群组和其他用户移除读的权限<br>chmod +x file --&gt; 文件file的所有用户增加运行的权限<br>chmod u=rwx,g=r,o=- file --&gt; 文件file的所有者分配读写和执行的权限，群组其它用户分配读的权限，其他用户没有任何权限<br></code></pre></td></tr></table></figure><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><p>搜索包含关键字的所有文件和目录。后接需要查找的文件名，也可以用正则表达式。</p><h4 id="安装-locate"><a href="#安装-locate" class="headerlink" title="安装 locate"></a>安装 locate</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install mlocate --&gt; 安装包<br>updatedb --&gt; 更新数据库<br>locate file.txt<br>locate fil*.txt<br></code></pre></td></tr></table></figure><p>「注意」<code>locate</code> 命令会去文件数据库中查找命令，而不是全磁盘查找，因此刚创建的文件并不会更新到数据库中，所以无法被查找到，可以执行 <code>updatedb</code> 命令去更新数据库。</p><p><img src="/img/post/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.assets/image-20250127212931565.png" alt="image-20250127212931565"></p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>用于查找文件，它会去遍历你的实际硬盘进行查找，而且它允许我们对每个找到的文件进行后续操作，功能非常强大。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find &lt;何处&gt; &lt;何物&gt; &lt;做什么&gt;<br></code></pre></td></tr></table></figure><ul><li><p>何处：指定在哪个目录查找，此目录的所有子目录也会被查找。</p></li><li><p>何物：查找什么，可以根据文件的名字来查找，也可以根据其大小来查找，还可以根据其最近访问时间来查找。</p></li><li><p>做什么：找到文件后，可以进行后续处理，如果不指定这个参数， <code>find</code> 命令只会显示找到的文件。</p></li></ul><h4 id="根据文件名查找"><a href="#根据文件名查找" class="headerlink" title="根据文件名查找"></a>根据文件名查找</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">find -name &quot;file.txt&quot; --&gt; 当前目录以及子目录下通过名称查找文件<br>find . -name &quot;syslog&quot; --&gt; 当前目录以及子目录下通过名称查找文件<br>find / -name &quot;syslog&quot; --&gt; 整个硬盘下查找syslog<br>find /var/log -name &quot;syslog&quot; --&gt; 在指定的目录/var/log下查找syslog文件<br>find /var/log -name &quot;syslog*&quot; --&gt; 查找syslog1、syslog2 ... 等文件，通配符表示所有<br>find /var/log -name &quot;*syslog*&quot; --&gt; 查找包含syslog的文件 <br></code></pre></td></tr></table></figure><p>「注意」 <code>find</code> 命令只会查找完全符合 “何物” 字符串的文件，而 <code>locate</code> 会查找所有包含关键字的文件。</p><h4 id="根据文件大小查找"><a href="#根据文件大小查找" class="headerlink" title="根据文件大小查找"></a>根据文件大小查找</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /var -size +10M --&gt; /var 目录下查找文件大小超过 10M 的文件<br>find /var -size -50k --&gt; /var 目录下查找文件大小小于 50k 的文件<br>find /var -size +1G --&gt; /var 目录下查找文件大小查过 1G 的文件<br>find /var -size 1M --&gt; /var 目录下查找文件大小等于 1M 的文件<br></code></pre></td></tr></table></figure><h4 id="根据文件最近访问时间查找"><a href="#根据文件最近访问时间查找" class="headerlink" title="根据文件最近访问时间查找"></a>根据文件最近访问时间查找</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find -name &quot;*.txt&quot; -atime -7  --&gt; 近 7天内访问过的.txt结尾的文件<br></code></pre></td></tr></table></figure><h4 id="仅查找目录或文件"><a href="#仅查找目录或文件" class="headerlink" title="仅查找目录或文件"></a>仅查找目录或文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name &quot;file&quot; -type f  --&gt; 只查找当前目录下的file文件<br>find . -name &quot;file&quot; -type d  --&gt; 只查找当前目录下的file目录<br></code></pre></td></tr></table></figure><h4 id="操作查找结果"><a href="#操作查找结果" class="headerlink" title="操作查找结果"></a>操作查找结果</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">find -name &quot;*.txt&quot; -printf &quot;%p - %u\n&quot; --&gt; 找出所有后缀为txt的文件，并按照 %p - %u\n 格式打印，其中%p=文件名，%u=文件所有者<br>find -name &quot;*.jpg&quot; -delete --&gt; 删除当前目录以及子目录下所有.jpg为后缀的文件，不会有删除提示，因此要慎用<br>find -name &quot;*.c&quot; -exec chmod 600 &#123;&#125; \; --&gt; 对每个.c结尾的文件，都进行 -exec 参数指定的操作，&#123;&#125; 会被查找到的文件替代，\; 是必须的结尾<br>find -name &quot;*.c&quot; -ok chmod 600 &#123;&#125; \; --&gt; 和上面的功能一直，会多一个确认提示<br></code></pre></td></tr></table></figure><h2 id="软件仓库"><a href="#软件仓库" class="headerlink" title="软件仓库"></a>软件仓库</h2><p><code>Linux</code> 下软件是以包的形式存在，一个软件包其实就是软件的所有文件的压缩包，是二进制的形式，包含了安装软件的所有指令。<code>Red Hat</code> 家族的软件包后缀名一般为 <code>.rpm</code> ，<code>Debian</code> 家族的软件包后缀是 <code>.deb</code> 。</p><p><code>Linux</code> 的包都存在一个仓库，叫做软件仓库，它可以使用 <code>yum</code> 来管理软件包， <code>yum</code> 是 <code>CentOS</code> 中默认的包管理工具，适用于 <code>Red Hat</code> 一族。可以理解成 <code>Node.js</code> 的 <code>npm</code> 。</p><h3 id="yum-常用命令"><a href="#yum-常用命令" class="headerlink" title="yum 常用命令"></a>yum 常用命令</h3><ul><li><p><code>yum update | yum upgrade</code> 更新软件包</p></li><li><p><code>yum search xxx</code> 搜索相应的软件包</p></li><li><p><code>yum install xxx</code> 安装软件包</p></li><li><p><code>yum remove xxx</code> 删除软件包</p></li></ul><h3 id="切换-CentOS-软件源"><a href="#切换-CentOS-软件源" class="headerlink" title="切换 CentOS 软件源"></a>切换 CentOS 软件源</h3><p>有时候 <code>CentOS</code> 默认的 <code>yum</code> 源不一定是国内镜像，导致 <code>yum</code> 在线安装及更新速度不是很理想。这时候需要将 <code>yum</code> 源设置为国内镜像站点。国内主要开源的镜像站点是网易和阿里云。</p><p>1、首先备份系统自带 <code>yum</code> 源配置文件 <code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></p><p>2、下载阿里云的 <code>yum</code> 源配置文件到 <code>/etc/yum.repos.d/CentOS7</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo<br></code></pre></td></tr></table></figure><p>3、生成缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum makecache<br></code></pre></td></tr></table></figure><h2 id="阅读手册"><a href="#阅读手册" class="headerlink" title="阅读手册"></a>阅读手册</h2><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><h4 id="安装更新-man"><a href="#安装更新-man" class="headerlink" title="安装更新 man"></a>安装更新 man</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install -y man-pages --&gt; 安装sudo mandb --&gt; 更新<br></code></pre></td></tr></table></figure><h4 id="man-手册种类"><a href="#man-手册种类" class="headerlink" title="man 手册种类"></a>man 手册种类</h4><ol><li><p>可执行程序或 <code>Shell</code> 命令；</p></li><li><p>系统调用（ <code>Linux</code> 内核提供的函数）；</p></li><li><p>库调用（程序库中的函数）；</p></li><li><p>文件（例如 <code>/etc/passwd</code> ）；</p></li><li><p>特殊文件（通常在 <code>/dev</code> 下）；</p></li><li><p>游戏；</p></li><li><p>杂项（ <code>man(7)</code> ，<code>groff(7)</code> ）；</p></li><li><p>系统管理命令（通常只能被 <code>root</code> 用户使用）；</p></li><li><p>内核子程序。</p></li></ol><h4 id="man-数字-命令"><a href="#man-数字-命令" class="headerlink" title="man + 数字 + 命令"></a>man + 数字 + 命令</h4><p>输入 man + 数字 + 命令 &#x2F; 函数，可以查到相关的命令和函数，若不加数字， <code>man</code> 默认从数字较小的手册中寻找相关命令和函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">man 3 rand  --&gt; 表示在手册的第三部分查找 rand 函数<br>man ls    --&gt; 查找 ls 用法手册<br></code></pre></td></tr></table></figure><p>man 手册核心区域解析：(以 <code>man pwd</code> 为例)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell">NAME<br>       pwd - print name of current/working directory<br><br>SYNOPSIS<br>       pwd [OPTION]...<br><br>DESCRIPTION<br>       Print the full filename of the current working directory.<br><br>       -L, --logical<br>              use PWD from environment, even if it contains symlinks<br><br>       -P, --physical<br>              avoid all symlinks<br><br>       --help display this help and exit<br><br>       --version<br>              output version information and exit<br><br>       If no option is specified, -P is assumed.<br>NOTE:  your shell may have its own version of pwd, which usually super‐<br>       sedes the version described here.  Please refer to your  shell&#x27;s  docu‐<br>       mentation for details about the options it supports.<br><br>AUTHOR<br>       Written by Jim Meyering.<br><br>REPORTING BUGS<br>       GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;<br>       Report pwd translation bugs to &lt;http://translationproject.org/team/&gt;<br><br>COPYRIGHT<br>       Copyright  ©  2017  Free Software Foundation, Inc.  License GPLv3+: GNU<br>       GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;.<br>       This is free software: you are free  to  change  and  redistribute  it.<br>       There is NO WARRANTY, to the extent permitted by law.<br><br>SEE ALSO<br>       getcwd(3)<br>Full documentation at: &lt;http://www.gnu.org/software/coreutils/pwd&gt;<br>       or available locally via: info &#x27;(coreutils) pwd invocation&#x27;<br></code></pre></td></tr></table></figure><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><code>man</code> 命令像新华词典一样可以查询到命令或函数的详细信息，但其实我们还有更加快捷的方式去查询， <code>command --help</code> 或 <code>command -h</code> ，它没有 <code>man</code> 命令显示的那么详细，但是它更加易于阅读。</p><p>个人常用的中文版Linux命令搜索引擎：<a href="https://wangchujiang.com/linux-command/">Linux命令搜索引擎</a></p><h1 id="Linux进阶"><a href="#Linux进阶" class="headerlink" title="Linux进阶"></a>Linux进阶</h1><h2 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h2><h2 id="重定向-管道流"><a href="#重定向-管道流" class="headerlink" title="重定向|管道流"></a>重定向|管道流</h2><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><h2 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h2><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><h2 id="文件压缩解压"><a href="#文件压缩解压" class="headerlink" title="文件压缩解压"></a>文件压缩解压</h2><h2 id="编译安装软件"><a href="#编译安装软件" class="headerlink" title="编译安装软件"></a>编译安装软件</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.滑动窗口最大值</title>
    <link href="/2025/01/22/011-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2025/01/22/011-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h1><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1]</span>, k = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h1 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h1><h2 id="单调递减队列"><a href="#单调递减队列" class="headerlink" title="单调递减队列"></a>单调递减队列</h2><p>这道题需要使用一种叫做<strong>单调递减队列</strong>的数据结构，<strong>这个队列的队列头始终是队列最大值，然后从头到尾数值依次变小</strong>，<strong>向该队列中添加元素时需要进行特殊处理</strong>，比如向队列中添加num，需要判断队列尾部的值是否大于num，如果小于，此时直接入队则会破坏队列单调递减的特性，则需要将队尾元素出队，然后继续判断，直到找到队列中比num值大的数或者队列为null，然后将num入队</p><h3 id="图解单调递减队列"><a href="#图解单调递减队列" class="headerlink" title="图解单调递减队列"></a>图解单调递减队列</h3><p><img src="/img/post/011-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.assets/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.gif"></p><p><img src="/img/post/011-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.assets/1737510565258-3.png"></p><p><img src="/img/post/011-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.assets/1737510565254-1.png"></p><p>使用单调递减队列，在滑动窗口时，将窗口内的值加入单调递减队列，如果单调队列的最大值「头节点」被移出滑动窗口，则移出头元素，代码如下<code>i &gt;= k &amp;&amp; nums[i - k] == queue.peek()</code>，其中<code>nums[ i - k ]</code>就是刚刚移出窗口的值，如果这个值大于了队列中的最大值，则说明这个最大值已经出了滑动窗口范围，需要从队列中移除<code>queue.poll()</code>；</p><p>输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3，动画如下：</p><p><img src="/../img/post/011-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.assets/1737510565254-2.gif"></p><p>当<code>i &gt;= k - 1</code>时，每次将队列中的最大值加入结果集合，why？因为一开始指针i是从0开始的，此时窗口还没有真正展开，此时队列中的最大值也不作数，因为你不确定后面窗口内会不会还有更大的值。简单来说，就是需要等窗口真正打开时，窗口内的最大值才能算数，比如现在 k &#x3D;&#x3D;3，即窗口大小为3，那么需要指针 i 指向 2 时窗口大小才真正成为3，此时才需要记录第一个最大值。</p><h1 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  单调递减队列，移出元素的逻辑中队列外实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonotonicStack</span> &#123;<br>    <span class="hljs-comment">// 双端队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 查看递减队列的第一个元素</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> deque.peekFirst();<br>    &#125;<br><br>    <span class="hljs-comment">// 查看并移除递减队列的第一个元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        deque.pollFirst();<br>    &#125;<br><br>    <span class="hljs-comment">// 向递减队列中添加元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(Integer m)</span> &#123;<br>        <span class="hljs-comment">// 队尾元素如果小于待添加元素，则出队</span><br>        <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; m) &#123;<br>            deque.pollLast();<br>        &#125;<br>        deque.offerLast(m);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-comment">// 单调递减队列</span><br>    <span class="hljs-type">MonotonicStack</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MonotonicStack</span>();<br>    <span class="hljs-comment">// 结果集合</span><br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>        queue.offer(num);<br>        <span class="hljs-comment">// 滑动窗口最前面的一个元素就是nums[ i - k ]</span><br>        <span class="hljs-comment">// 如果滑动窗口前面的第一个元素等于了队列中的最大值，说明这个最大值已经出了滑动窗口范围</span><br>        <span class="hljs-keyword">if</span> (i &gt;= k &amp;&amp; nums[i - k] == queue.peek()) &#123;<br>            queue.poll();<br>        &#125;<br>        <span class="hljs-comment">// 从i &gt;= k-1 开始，每次将队列中的最大值加入结果集合</span><br>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) &#123;<br>            list.add(queue.peek());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> list.stream()<br>            .mapToInt(Integer::intValue)<br>            .toArray();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 移出元素的逻辑在队列中实现</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br>        Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-comment">//弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-keyword">if</span> (!deque.isEmpty() &amp;&amp; val == deque.peek()) &#123;<br>                deque.poll();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出，保证队列元素单调递减</span><br>        <span class="hljs-comment">// 比如此时队列元素3,1，此时2将要入队，比1大，所以1弹出，此时队列：3,2</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>            <span class="hljs-keyword">while</span> (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) &#123;<br>                deque.removeLast();<br>            &#125;<br>            deque.add(val);<br>        &#125;<br><br>        <span class="hljs-comment">//队列队顶元素始终为最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> deque.peek();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] maxSlidingWindow(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums;<br>        &#125;<br>        <span class="hljs-comment">//存放结果元素的数组</span><br>        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">resIdx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//自定义队列</span><br>        <span class="hljs-type">MyQueue</span> <span class="hljs-variable">myQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyQueue</span>();<br>        <span class="hljs-comment">//先将前k的元素放入队列</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            myQueue.add(nums[i]);<br>        &#125;<br>        res[resIdx++] = myQueue.peek();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//滑动窗口移除最前面的元素</span><br>            myQueue.poll(nums[i - k]);<br>            <span class="hljs-comment">//滑动窗口加入最后面的元素</span><br>            myQueue.add(nums[i]);<br>            <span class="hljs-comment">//记录对应的最大值</span><br>            res[resIdx++] = myQueue.peek();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.和为K的子数组</title>
    <link href="/2025/01/21/010-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2025/01/21/010-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,1], k = 2</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,2,3], k = 3</span><br><span class="hljs-string">输出：2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-107 &lt;= k &lt;= 107</code></li></ul><h1 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h1><div class="note note-primary">            <ol><li>前缀和的概念<br>  什么是前缀和呢？前缀和是指数组中从第一个元素到当前位置的所有元素的累加和。例如，对于数组 <code>[1, 2, 3]</code>，前缀和就是：</li></ol><ul><li><code>前缀和[0] = 0</code>（表示没有任何元素时的和）</li><li><code>前缀和[1] = 1</code>（表示第一个元素的和）</li><li><code>前缀和[2] = 1 + 2 = 3</code>（表示前两个元素的和）</li><li><code>前缀和[3] = 1 + 2 + 3 = 6</code>（表示所有元素的和）</li></ul><ol start="2"><li><p>哈希表的作用<br>我们使用哈希表来存储每一个前缀和出现的次数，目的是为了快速查询某个前缀和是否存在，避免重复计算。</p></li><li><p>算法步骤</p></li></ol><p>  <strong>初始化变量：</strong></p><ul><li><code>count</code> 用来记录符合条件的子数组的数量。</li><li><code>preSum</code> 用来保存当前的前缀和（即当前遍历到的位置的累加和）。</li><li><code>map</code> 用来记录每个前缀和出现的次数，初始时将 <code>map.put(0, 1)</code>，因为前缀和为 <code>0</code> 出现过一次（这个是为了考虑从数组的开头就符合条件的情况）。</li></ul><p>  <strong>遍历数组：</strong></p><ul><li>对每个元素 <code>num</code>，我们更新 <code>preSum</code>（即 <code>preSum += num</code>，<strong>计算当前的前缀和</strong>）。</li></ul><p>  <strong>检查是否存在符合条件的子数组</strong>：</p><ul><li>我们判断当前的 <code>preSum - k</code> 是否在哈希表中出现过。如果出现过，说明存在一个子数组的和等于 <code>k</code>。这个子数组的起始位置就是哈希表中存储的 <code>preSum - k</code> 对应的前缀和位置。</li><li>如果存在，则把 <code>map.get(preSum - k)</code> 的值加到 <code>count</code> 上，这个值代表了出现过多少次 <code>preSum - k</code>，也就是说，找到了多少个和为 <code>k</code> 的子数组。</li></ul><p>  <strong>更新哈希表</strong>：</p><ul><li>把当前的 <code>preSum</code> 存入哈希表 <code>map</code>，如果该前缀和已经出现过，则将其计数加 1；如果没有出现过，则初始化其计数为 1。</li></ul><p>  <strong>返回结果</strong></p><p>  最后，算法返回 <code>count</code>，即数组中和为 <code>k</code> 的子数组的个数。</p>          </div><h2 id="图解前缀和"><a href="#图解前缀和" class="headerlink" title="图解前缀和"></a>图解前缀和</h2><p><img src="/img/post/010-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.assets/PixPin_2025-01-22_08-22-26.gif" alt="图解前缀和"></p><p><img src="/img/post/010-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.assets/1737505399752-29.png" alt="详解前缀和"></p><h1 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * O（n2）时间复杂度高</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; start &lt; nums.length; start++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> start; end &gt;= <span class="hljs-number">0</span>; end--) &#123;<br>            sum += nums[end];<br>            <span class="hljs-keyword">if</span> (sum == k) &#123;<br>                count++;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 前缀和 + 哈希表优化</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">preSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 计算前缀和</span><br>    <span class="hljs-comment">// 存放出现过的前缀和「key:前缀和，value:这个前缀和出现过多少次」</span><br>    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">// 初始化map，前缀和为，出现过一次</span><br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        preSum += num; <span class="hljs-comment">// 累加前缀和</span><br>        <span class="hljs-keyword">if</span> (map.containsKey(preSum - k)) &#123;<br>            <span class="hljs-comment">// 如果出现过preSum-k的前缀和，则累加出现的次数</span><br>            count += map.get(preSum - k);<br>        &#125;<br>        <span class="hljs-comment">// 将当前前缀和存入map集合，如果原先map集合中存在，则累加value，否则value为1</span><br>        map.put(preSum, map.getOrDefault(preSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.找到字符串中所有字母异位词</title>
    <link href="/2025/01/20/009-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <url>/2025/01/20/009-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h1><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 </p><p><strong>示例 1:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;abab&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出: <span class="hljs-selector-attr">[0,1,2]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">1</span> 的子串是 <span class="hljs-string">&quot;ba&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">2</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length, p.length &lt;= 3 * 104</code></li><li><code>s</code> 和 <code>p</code> 仅包含小写字母</li></ul><h1 id="题解思路"><a href="#题解思路" class="headerlink" title="题解思路"></a>题解思路</h1><div class="note note-primary">            <p><strong>初始化变量</strong>：</p><ul><li>创建一个 <code>list</code> 用于存储所有找到的子串的起始位置。</li><li>如果 <code>s</code> 的长度小于 <code>p</code> 的长度，直接返回空列表，因为不可能存在任何字母异位词。</li><li>创建两个频率数组 <code>pFreq</code> 和 <code>sFreq</code>，分别用来存储字符串 <code>p</code> 和当前滑动窗口的字符频率。</li></ul><p><strong>填充</strong> <strong><code>p</code></strong> <strong>的字符频率</strong>：</p><ul><li>遍历字符串 <code>p</code> 中的每个字符，并在 <code>pFreq</code> 数组中对应位置上增加计数。<code>pFreq[c - &#39;a&#39;]++</code> 这一步是将字符转换为字母的索引（’a’ 对应 0，’b’ 对应 1，依此类推）。</li></ul><p><strong>初始化滑动窗口</strong>：</p><ul><li>使用一个大小为 <code>p.length()</code> 的滑动窗口，初始化窗口的字符频率。遍历字符串 <code>s</code> 的前 <code>p.length()</code> 个字符，并更新 <code>sFreq</code> 数组。</li></ul><p><strong>比较初始窗口与</strong> <strong><code>p</code></strong> <strong>的字符频率</strong>：</p><ul><li>如果初始窗口（即字符串 <code>s</code> 的前 <code>p.length()</code> 个字符）的字符频率与 <code>p</code> 的字符频率相同，说明当前窗口是一个异位词，将 <code>0</code>（起始位置）加入 <code>list</code>。</li></ul><p><strong>滑动窗口</strong>：</p><ul><li>从 <code>p.length()</code> 开始，逐步向右滑动窗口。对于每个新的字符 <code>s[end]</code>，<code>begin = end - p.length()</code>执行以下操作：</li></ul><ol><li>增加当前字符 <code>s[end]</code> 的频率。</li><li>减少窗口左侧字符 <code>s[begin]</code> 的频率，<code>begin</code> 是当前窗口的起始位置。</li><li>比较 <code>sFreq</code> 和 <code>pFreq</code>，如果两者相等，说明当前窗口是 <code>p</code> 的一个异位词，将 <code>begin + 1</code>（当前窗口的起始位置）加入 <code>list</code>。</li></ol><ul><li>每次滑动窗口，<code>begin</code> 和 <code>end</code> 更新为新的窗口边界。</li></ul><p><strong>返回结果</strong>：</p><ul><li>最终返回 <code>list</code>，其中包含所有符合条件的子串的起始位置。</li></ul>          </div><h1 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义一个对象比较是否是字母异位词,耗时时间长，性能不高</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Data</span><span class="hljs-params">(String c)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; c.length(); i++) &#123;<br>            data[c.charAt(i) - <span class="hljs-number">97</span>]++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == object) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (object == <span class="hljs-literal">null</span> || getClass() != object.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Data</span> <span class="hljs-variable">data1</span> <span class="hljs-operator">=</span> (Data) object;<br>        <span class="hljs-keyword">return</span> Objects.deepEquals(data, data1.data);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Arrays.hashCode(data);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 如果s的长度比p的长度还小，直接返回</span><br>    <span class="hljs-keyword">if</span> (s.length() &lt; p.length()) <span class="hljs-keyword">return</span> list;<br>    <span class="hljs-comment">// 创建字符串p的Data对象</span><br>    <span class="hljs-type">Data</span> <span class="hljs-variable">pData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>(p);<br>    <span class="hljs-comment">// 定义窗口大小</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> p.length();<br>    <span class="hljs-keyword">while</span> (end &lt;= s.length()) &#123;<br>        <span class="hljs-comment">// 截取窗口内的字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">substring</span> <span class="hljs-operator">=</span> s.substring(begin, end);<br>        <span class="hljs-type">Data</span> <span class="hljs-variable">subData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>(substring);<br>        <span class="hljs-comment">// 比较窗口内的字符串于字符串p是否是字母异位词</span><br>        <span class="hljs-keyword">if</span> (subData.equals(pData)) &#123;<br>            list.add(begin);<br>        &#125;<br>        <span class="hljs-comment">// 移动窗口</span><br>        begin++;<br>        end++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (s.length() &lt; p.length()) <span class="hljs-keyword">return</span> list;<br>    <span class="hljs-comment">// 创建字符频率数组</span><br>    <span class="hljs-type">int</span>[] pFreq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];  <span class="hljs-comment">// p字符串的字符频率</span><br>    <span class="hljs-type">int</span>[] sFreq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];  <span class="hljs-comment">// 当前滑动窗口的字符频率</span><br>    <span class="hljs-comment">// 填充 p 字符串的频率</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : p.toCharArray()) &#123;<br>        pFreq[c - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-comment">// 初始化滑动窗口</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length(); i++) &#123;<br>        sFreq[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-comment">// 如果窗口的字符频率与 p 的字符频率相同，记录起始位置</span><br>    <span class="hljs-keyword">if</span> (Arrays.equals(pFreq, sFreq)) &#123;<br>        list.add(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 滑动窗口</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> p.length(); end &lt; s.length(); end++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> end - p.length();<br>        <span class="hljs-comment">// 新增字符</span><br>        sFreq[s.charAt(end) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-comment">// 移除旧字符</span><br>        sFreq[s.charAt(begin) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        <span class="hljs-comment">// 比较窗口和 p 的字符频率</span><br>        <span class="hljs-keyword">if</span> (Arrays.equals(pFreq, sFreq)) &#123;<br>            list.add(begin + <span class="hljs-number">1</span>); <span class="hljs-comment">// 新的窗口的begin需要+1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.无重复字符的最长子串</title>
    <link href="/2025/01/20/008-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2025/01/20/008-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h1><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><div class="note note-primary">            <p>核心思想：滑动窗口</p>          </div><p><strong>要点：</strong></p><ol><li>用 begin 和 end 表示子串开始和结束位置</li><li>用 hash 表检查重复字符「key：字符，value：字符下标」</li><li>从左向右查看每个字符, 如果:<ol><li><strong>没遇到重复字符，调整 end++</strong></li><li><strong>遇到重复的字符，调整 begin（调整begin到重复字符的下一位，如果重复字符的下一位&lt;begin，则仍然取begin，因为begin不可能倒退）</strong></li><li>将当前字符放入 hash 表，<strong>hash表的键表示当前字符，值表示当前字符的索引</strong></li></ol></li><li>end - begin + 1 是当前子串长度</li></ol><h1 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用链表充当子串，如果出现重复字符，则不断删除链表头中的字符，直到不出现重复，时间复杂度高</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> s</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">// 参数校验</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的右边界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最长子串</span><br>    <span class="hljs-comment">// 这个list链表就相当于连续子串</span><br>    LinkedList&lt;Character&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (right &lt; s.length()) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(right);<br>        <span class="hljs-comment">// 如果连续子串中出现重复的字符，则一直删除子串头的字符，直到不出现重复</span><br>        <span class="hljs-keyword">while</span> (list.contains(c)) &#123;<br>            list.removeFirst();<br>        &#125;<br>        <span class="hljs-comment">// 将当前字符添加到子串中</span><br>        list.addLast(c);<br>        right++;<br>        <span class="hljs-comment">// 记录最长子串</span><br>        max = Math.max(list.size(), max);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用map检查是否有重复字符</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">//使用map检查是否有重复字符，其中key-字符 value-字符下标</span><br>    Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//定义maxLength变量记录最长子串</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; end &lt; s.length(); end++) &#123;<br>        <span class="hljs-comment">//遍历字符串，获取每一个字符</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(end);<br>        <span class="hljs-comment">//如果当前字符存在map中，说明重复了</span><br>        <span class="hljs-keyword">if</span> (map.containsKey(ch)) &#123; <span class="hljs-comment">//重复</span><br>            <span class="hljs-comment">//将begin修改为在begin和end范围内，重复字符的下一个字符索引</span><br>            <span class="hljs-comment">// 如果重复字符的下标比begin还小，则还取begin，因为begin不能倒退</span><br>            begin = Math.max(begin, map.get(ch) + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//将重复字符的下标修改</span><br>            map.put(ch, end);<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//不重复</span><br>            <span class="hljs-comment">//将字符和字符下标放入map集合中</span><br>            map.put(ch, end);<br>        &#125;<br>        <span class="hljs-comment">//最大长度即为每次循环得到的字符串的最大值</span><br>        maxLength = Math.max(maxLength, end - begin + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//返回无重复最大子串长度</span><br>    <span class="hljs-keyword">return</span> maxLength;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用数组代替哈希表</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring2</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-comment">//使用数组检查是否有重复字符，其中 索引-字符 值-字符下标</span><br>    <span class="hljs-type">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">128</span>];<br>    <span class="hljs-comment">// 初始全部填充为-1，因为字符下标不可能为-1</span><br>    Arrays.fill(map, -<span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//定义maxLength变量记录最长子串</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; end &lt; s.length(); end++) &#123;<br>        <span class="hljs-comment">//遍历字符串，获取每一个字符</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(end);<br>        <span class="hljs-comment">//如果当前字符存在map中，说明重复了</span><br>        <span class="hljs-keyword">if</span> (map[ch] != -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//之前出现过，重复 </span><br>            <span class="hljs-comment">//将begin修改为在begin和end范围内，重复字符的下一个字符索引</span><br>            begin = Math.max(begin, map[ch] + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//将重复字符的下标修改</span><br>            map[ch] = end;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//不重复</span><br>            <span class="hljs-comment">//将字符和字符下标放入map集合中</span><br>            map[ch] = end;<br>        &#125;<br>        <span class="hljs-comment">//最大长度即为每次循环得到的字符串的最大值</span><br>        maxLength = Math.max(maxLength, end - begin + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//返回无重复最大子串长度</span><br>    <span class="hljs-keyword">return</span> maxLength;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的BufferPool和ChangeBuffer</title>
    <link href="/2025/01/20/MySQL%E7%9A%84BufferPool%E5%92%8CChangeBuffer/"/>
    <url>/2025/01/20/MySQL%E7%9A%84BufferPool%E5%92%8CChangeBuffer/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><p>MySQL可以通过B+树来减少索引查找时的磁盘IO次数，但是每次查找、新增都去做磁盘IO的话，如果频繁操作还是会遇到瓶颈。因此就有<strong>Buffer pool</strong>和<strong>Change buffer</strong>的出现。</p><h2 id="Buffer-pool"><a href="#Buffer-pool" class="headerlink" title="Buffer pool"></a>Buffer pool</h2><p><strong>目的：buffer pool是为了减少磁盘IO的读写次数。</strong></p><p>假如没有buffer pool，则每次查询都会从磁盘中读取，进行IO操作。</p><p>因此会在内存中专门取一大块区域用作Buffer pool用来保存一些已经读过的页和周围的页数据（<strong>空间局部性</strong>），这样的的话当下次<strong>查询数据</strong>时会在Buffer pool查询是否存在需要的页，减少读写IO次数。</p><p>当修改数据时，同样会先修改buffer pool中的数据，被修改的页称为脏页，一般会采用<strong>redo log持久化机制</strong>，将脏页统一写入到磁盘中。</p><h3 id="buffer-pool结构"><a href="#buffer-pool结构" class="headerlink" title="buffer pool结构"></a>buffer pool结构</h3><p>buffer pool涉及到三个链表：</p><p><img src="/img/post/MySQL%E7%9A%84BufferPool%E5%92%8CChangeBuffer.assets/czljpr6w6ss52_95f7676e495d46d7986fed0584be960c.png" alt="buffer pool涉及到的三个链表"></p><ul><li><p>free list 组织 buffer pool 中未使用的<strong>空闲页</strong>；</p></li><li><p>flush list 组织buffer pool 中<strong>脏页</strong>，也就是待刷盘的页；</p></li><li><p>lru list 组织 buffer pool 中冷热数据，当 buffer pool 没有空闲页，将从 lru list 中最久未使用的数据进行淘汰；</p></li></ul><h3 id="Buffer-pool-LRU算法"><a href="#Buffer-pool-LRU算法" class="headerlink" title="Buffer pool&amp;LRU算法"></a>Buffer pool&amp;LRU算法</h3><p>buffer pool 优化了LRU方法。因为MySQL有<strong>预读机制</strong>，每次将缓存页加载进Buffer pool时，会将目标缓存页附近的数据页也加进来。就是磁盘读取的空间局部性原理。</p><p>这样会导致一个问题，可能被预读加进来的数据页，再之后可能长时间就没访问过了。</p><h4 id="优化一、冷热数据"><a href="#优化一、冷热数据" class="headerlink" title="优化一、冷热数据"></a>优化一、冷热数据</h4><p><strong>目的：解决预读失效问题</strong></p><p><img src="/img/post/MySQL%E7%9A%84BufferPool%E5%92%8CChangeBuffer.assets/czljpr6w6ss52_65433420564e45cb938ad162c7f421eb.png" alt="buff pool的LRU结构"></p><p><strong>Buffer pool中5&#x2F;8的区域为new sublist，3&#x2F;8的区域为old sublist</strong>。</p><blockquote><ul><li>因此数据加入pool缓冲池时，优先进入old sublist，<strong>页被访问时</strong>会进入new sublist，在free list<br>不足时，优先刷入那些old sublist区域的页进入磁盘，再清空buffer pool区域。</li><li>所以那些被预读加进来的数据页，如果没被访问，就会一直呆在old区域，等到空间不足时，会被提前清空。这样就能解决预读失效的问题。</li></ul></blockquote><h4 id="优化二、时间阈值"><a href="#优化二、时间阈值" class="headerlink" title="优化二、时间阈值"></a>优化二、时间阈值</h4><p><strong>目的：解决批量查询数据时，大量热数据淘汰问题</strong></p><blockquote><p>页被访问，且在old sublist停留时间超过配置阈值的，才进入new sublist，以解决批量数据访问，大量热数据淘汰的问题。通常阈值设置为1s。</p></blockquote><p><strong>为什么是1s?</strong></p><p>因为预读机制将加载进来的数据页通常是会在1s之内就访问，如果1s之内没有访问，可能1s之后就不会再被访问了。</p><p>因此如果这时将这些访问了的缓存页就加进new区域也不太好，因此通过配置时间阈值。在1s之后仍然被访问的数据页才进入new区域，并放入new区域的头部，说明后续可能还会被访问到。而1s之前被访问的数据页就不变。</p><h2 id="Change-buffer"><a href="#Change-buffer" class="headerlink" title="Change buffer"></a>Change buffer</h2><p>假如一个需要修改的页数据没有在buffer pool中，我们需要怎么操作：</p><blockquote><ol><li>将数据页调入到buffer pool中， 一次随机磁盘IO</li><li>更新buffer pool中的数据 ， 一次内存IO</li><li>将修改写入redo log，一次磁盘顺序写IO</li></ol></blockquote><p>看起来操作还行，但是如果在写多读少的场景下的话，我们有更好的方法，也就是innodb的change buffer。</p><h3 id="Change-buffer工作原理"><a href="#Change-buffer工作原理" class="headerlink" title="Change buffer工作原理"></a>Change buffer工作原理</h3><blockquote><p>Change buffer <span class="label label-success">缓存</span><strong>非唯一索引</strong>的<span class="label label-success">数据变更</span>（DML 操作，只记录操作，不记录结果），当访问这个数据页或者定期时间到达Change buffer 中的数据将会异步 merge 到磁盘当中；</p></blockquote><p>因此对于刚刚的需要修改的页数据没有在buffer pool中，使用change buffer的操作：</p><blockquote><ol><li>将修改的操作写入到change buffer中 ，一次内存IO</li><li>写入日志到redo log中，等待触发merge，一次磁盘顺序写IO</li></ol></blockquote><p>可以看到使用change buffer的话在写多读少的场景下会节省最耗时的<strong>随机磁盘IO</strong>读写的次数。</p><h3 id="change-buffer不适用的场景"><a href="#change-buffer不适用的场景" class="headerlink" title="change buffer不适用的场景"></a>change buffer不适用的场景</h3><blockquote><ul><li><strong>唯一索引的场景</strong>：唯一索引需要判断是否冲突，也就是是否唯一（唯一性校验），这个判断需要全局扫描，需要从磁盘读数据，change buffer也就没什么用了。</li><li><strong>写少读多的场景</strong>：因为修改数据页后读取该页会触发merge，而我们的目的就是为了把多次数据页的修改通过一次merge更新到磁盘中，如果读数据的场景多了，那么merge的次数多，也不会减少IO操作次数了。</li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note note-primary">            <p>当数据不在buffer pool中，修改页数据后然后读取数据的步骤，理解一下buffer pool怎么和change buffer工作的：</p><p><strong>修改操作：</strong></p><ol><li>在buffer pool匹配不到页数据；</li><li>在change buffer中记录该数据的修改操作<span class="label label-success">「缓存数据变更」</span>；</li></ol><p><strong>查询操作：</strong></p><ol><li>在buffer pool 中匹配不到页数据；</li><li>在磁盘中读取页数据；</li><li>从change buffer中读取之前记录的数据变更操作，将数据做merge操作后放回buffer pool中；</li></ol>          </div>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>BufferPool</tag>
      
      <tag>ChangeBuffer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.接雨水</title>
    <link href="/2025/01/15/007-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2025/01/15/007-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h1><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="/img/post/2-%E6%8E%A5%E9%9B%A8%E6%B0%B4.assets/rainwatertrap.png" alt="示例"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：height = [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0,1,0,2</span>,<span class="hljs-number">1,0,1,3</span>,<span class="hljs-number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,2,0,3,2,5]</span><br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><blockquote><p> <strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul></blockquote><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><p>为什么使用单调栈？</p><p>因为如果柱子的高度是单调递减的，那么肯定存不下雨水，这样我们就将单调递减的柱子加入单调栈，这样如果一个高的柱子入栈，会导致栈顶元素出栈，我们就可以做出栈的时候进行水的容量计算「<strong>只有出栈的时候可能会存雨水</strong>」</p></blockquote><p><img src="/img/post/2-%E6%8E%A5%E9%9B%A8%E6%B0%B4.assets/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E5%8A%A8%E7%94%BB.gif" alt="入栈动画演示"></p><ul><li>遍历所有的柱子，对于每个柱子，将其信息存储在 <code>right</code> 中。</li><li>当栈不为空且栈顶元素的高度小于 <code>right</code> 的高度时，从栈中弹出元素 <code>pop</code>，并取栈顶元素作为 <code>left</code>。</li><li>计算 <code>left</code> 和 <code>right</code> 之间能存储雨水的空间，即根据宽度和高度的计算（宽度为 <code>right.index - left.index - 1</code>，高度为 <code>Math.min(right.height, left.height) - pop.height</code>），将计算结果累加到 <code>sum</code> 中。</li><li>最终得到的 <code>sum</code> 就是整个柱状图能存储的雨水总量。</li></ul><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果柱子的高度是单调递减的，那么肯定存不下雨水</span><br><span class="hljs-comment">// 如果出现了一个比之前柱子高的柱子，才有可能有空间能够存下雨水</span><br><span class="hljs-comment">// 使用一个单调 栈存放每个柱子的高度，当新来的柱子更高时，不满足单调栈的规则，需要弹出栈顶那些高度低的柱子的时候 计算雨水容量</span><br><span class="hljs-comment">// 此时涉及到三个变量，一个是刚加入的柱子，命名为right，一个是被弹出的柱子，命名为pop，还有一个是被弹出柱子左侧的柱子，命名left</span><br><span class="hljs-comment">// 水的容量 = (right的索引-left的索引-1) * min(right.height,left.height) - pop.height</span><br><span class="hljs-comment">// 因为对于每个柱子我们都需要用它的索引和高度两个状态，因此我们封装一个Data类来描述柱子</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] heights)</span> &#123;<br>    LinkedList&lt;Data&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; heights.length; i++) &#123;<br>        <span class="hljs-type">Data</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>(heights[i], i); <span class="hljs-comment">// 即将放入单调栈中的柱子</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek().height &lt; right.height) &#123; <span class="hljs-comment">// 查看单调栈顶元素是否小于准备入栈的元素</span><br>            <span class="hljs-type">Data</span> <span class="hljs-variable">pop</span> <span class="hljs-operator">=</span> stack.pop(); <span class="hljs-comment">// 从栈中pop出的柱子</span><br>            <span class="hljs-type">Data</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> stack.peek(); <span class="hljs-comment">// 栈中pop出柱子后的栈顶柱子就是原先pop柱子左侧的柱子</span><br>            <span class="hljs-comment">// 如果左侧的柱子不为null</span><br>            <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 计算水的容量并累加</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> right.index - left.index - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> Math.min(right.height, left.height) - pop.height;<br>                sum += width * height;<br>            &#125;<br>        &#125;<br>        stack.push(right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> height; <span class="hljs-comment">// 柱子高度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index; <span class="hljs-comment">// 柱子的索引</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Data</span><span class="hljs-params">(<span class="hljs-type">int</span> height, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-built_in">this</span>.height = height;<br>        <span class="hljs-built_in">this</span>.index = index;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.三数之和</title>
    <link href="/2025/01/15/006-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2025/01/15/006-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h1><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><blockquote><p><strong>注意</strong>：答案中不可以包含重复的三元组。</p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[-1,0,1,2,-1,-4]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[-1,-1,2]</span>,<span class="hljs-comment">[-1,0,1]</span>]</span><br>解释：<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> = (-1) + 0 + 1 = 0 。<br>nums<span class="hljs-comment">[1]</span> + nums<span class="hljs-comment">[2]</span> + nums<span class="hljs-comment">[4]</span> = 0 + 1 + (-1) = 0 。<br>nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[3]</span> + nums<span class="hljs-comment">[4]</span> = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 <span class="hljs-comment">[-1,0,1]</span> 和 <span class="hljs-comment">[-1,-1,2]</span> 。<br>注意，输出的顺序和三元组的顺序并不重要。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0,1,1]</span><br>输出：<span class="hljs-comment">[]</span><br>解释：唯一可能的三元组和不为 0 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[0,0,0]]</span><br>解释：唯一可能的三元组和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><blockquote><p>视频讲解：<a href="https://www.bilibili.com/video/BV1rv4y1H7o6/?p=178">https://www.bilibili.com/video/BV1rv4y1H7o6/?p=178</a></p></blockquote><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>这道题目使用双指针法 要比哈希法高效一些，那么来讲解一下具体实现的思路。</p><p>动画效果如下：</p><p><img src="/img/post/1-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.assets/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif" alt="三数之和"></p><p><strong>拿这个nums数组来举例，首先将数组排序，然后有一层</strong>for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。（<strong>相当于三个指针）</strong></p><p>依然还是在数组中找到 abc 使得a + b +c &#x3D;0，我们这里相当于<code>a = nums[i]，b = nums[left]，c = nums[right]</code>。</p><p>接下来如何移动left 和right呢， 如果<strong>nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</strong></p><p>如果 <strong>nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。</strong></p><h3 id="去重逻辑的思考"><a href="#去重逻辑的思考" class="headerlink" title="去重逻辑的思考"></a>去重逻辑的思考</h3><h4 id="a的去重"><a href="#a的去重" class="headerlink" title="a的去重"></a>a的去重</h4><p>说到去重，其实主要考虑三个数的去重。 <strong>a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]</strong></p><p>a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。</p><p>但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。</p><p>有同学可能想，这不都一样吗。</p><p>其实不一样！</p><p>都是和 nums[i]进行比较，是比较它的前一个，还是比较它的后一个。</p><p>如果我们的写法是 这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">if</span> (nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 去重操作</span><br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</p><p>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</p><p>所以这里是有两个重复的维度。</p><p>那么应该这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。</p><p><strong>这是一个非常细节的思考过程。</strong></p><h4 id="b与c的去重"><a href="#b与c的去重" class="headerlink" title="b与c的去重"></a>b与c的去重</h4><p>很多同学写本题的时候，去重的逻辑多加了 对right 和left 的去重：（代码中注释部分）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) &#123;<br>        right--;<br>        <span class="hljs-comment">// 去重 right</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="hljs-number">1</span>]) right--;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) &#123;<br>        left++;<br>        <span class="hljs-comment">// 去重 left</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="hljs-number">1</span>]) left++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但细想一下，这种去重其实对提升程序运行效率是没有帮助的。</p><p>拿right去重为例，即使不加这个去重逻辑，依然根据 <code>while (right &gt; left)</code> 和 <code>if (nums[i] + nums[left] + nums[right] &gt; 0)</code> 去完成right– 的操作。</p><p>多加了 <code>while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;</code> 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少 判断的逻辑。</p><p><strong>最直白的思考过程，就是right还是一个数一个数的减下去的，所以在哪里减的都是一样的。</strong></p><p>所以这种去重 是可以不加的。 仅仅是 把去重的逻辑提前了而已</p><p>而真正去重b和c的代码应该放在找到一个三元组之后，对b 和 c去重，<strong>并且去重后需要对left和right同时收缩</strong></p><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><h3 id="三指针"><a href="#三指针" class="headerlink" title="三指针"></a>三指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 三指针</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// 先排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// 排序后数组的第一个值如果大于0，则三数之和后一定不可能有等于0的情况，直接返回</span><br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        使用i指针固定一个值a,使用left指针固定一个值b，使用right指针固定一个值c</span><br><span class="hljs-comment">        指针 i 的取值范围 [0,nums.length-3],因为后面最少还需要留两个位置给right和left</span><br><span class="hljs-comment">     */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-comment">// 对a进行去重</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>                <span class="hljs-comment">// 三数之和</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[left] + nums[right];<br>                <span class="hljs-comment">// 如果三数之和大于0，则需要将right--，反之将left++</span><br>                <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123;<br>                    right--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                    left++;<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 找到第一个三数和为0，加入结果集合后对数字b和c进行去重</span><br>                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));<br>                    <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                    left++;<br>                    right--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回溯算法，可同时解决四数之和等问题</span><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum3</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>       Arrays.sort(nums); <span class="hljs-comment">// 排序</span><br>       dfs(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, nums, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(), result);<br>       <span class="hljs-keyword">return</span> result;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> n 三数之和 n == 3  四数之和 n == 4</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> i 左边界</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> j 右边界</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> nums 数组</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> target 目标值</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> stack 栈 回溯用</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> result 结果集合 -&gt; 存放最后的结果</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target,</span><br><span class="hljs-params">                   LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;<br>       <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>           <span class="hljs-comment">// 如果n==2,走求解两数之和的逻辑</span><br>           towSum(nums, i, j, target, stack, result);<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt; j - (n - <span class="hljs-number">2</span>); k++) &#123;<br>           <span class="hljs-keyword">if</span> (k &gt; i &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 去重</span><br>               <span class="hljs-keyword">continue</span>;<br>           &#125;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[k];<br>           stack.push(num); <span class="hljs-comment">// 固定一个值</span><br>           dfs(n - <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>, j, nums, target - num, stack, result);<br>           stack.pop();<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 两数之和</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> i</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> j</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> target</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> stack</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> result</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">towSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> target,</span><br><span class="hljs-params">                       LinkedList&lt;Integer&gt; stack, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;<br><br>       <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[j];<br>           <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>               i++;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;<br>               j--;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(stack);<br>               list.add(nums[i]);<br>               list.add(nums[j]);<br>               result.add(list);<br>               <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 去重</span><br>                   i++;<br>               &#125;<br>               <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] == nums[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 去重</span><br>                   j--;<br>               &#125;<br>               i++;<br>               j--;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码随想录：<a href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html">https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html</a><br>黑马满一航老师的数据结构「重点讲了回溯实现」：<a href="https://www.bilibili.com/video/BV1rv4y1H7o6/?p=178">https://www.bilibili.com/video/BV1rv4y1H7o6/?p=178</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.盛水最多的容器</title>
    <link href="/2025/01/15/005-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2025/01/15/005-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h1><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明</strong>：你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="/img/post/5-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8.assets/question_11.jpg" alt="盛水最多的容器"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= height[i] &lt;= 104</code></li></ul><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p><strong>核心思想</strong>：<span class="label label-info"> 双指针</span></p><p>定义两个指针 i 和 j，分别在数组的两端，while 循环条件为两个指针不相遇</p><p>然后每次取两个指针所在索引处的值作为盛放水的挡板，因为只能取最短的挡板作为边界才能存放水，因此判断哪个挡板更低，对应到数组上就是哪个指针对应的数组的值更低</p><p>通过这个值，和 x 轴的长度，也就是（j-i）来计算当前容量，然后维护一个max记录最大容量，每次计算完成后，选择低的哪个挡板指针向中心靠拢</p><div class="note note-primary">            <p><strong>「只有移动低的挡板到更高的挡板容量才有可能更大，否则一直按照低的挡板算容量，容量不可能再变大了」</strong></p>          </div><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> OldGj 2025/1/9</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@apiNote</span> 11. 盛最多水的容器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_005_maxArea</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">if</span> (height[i] &lt; height[j]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> (j - i) * height[i];<br>                max = Math.max(area, max);<br>                i++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> (j - i) * height[j];<br>                max = Math.max(area, max);<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.移动零</title>
    <link href="/2025/01/15/004-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <url>/2025/01/15/004-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: nums = <span class="hljs-string">[0,1,0,3,12]</span><br>输出: <span class="hljs-string">[1,3,12,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: nums = <span class="hljs-comment">[0]</span><br>输出: <span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><p><strong>进阶</strong>：你能尽量减少完成的操作次数吗？</p><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>两种思路，一种思路是<span class="label label-info">顺序遍历数组</span>，再定义一个指针从0开始构建数组，遍历到非0数，则将其放到构建数组的指针索引处，遍历完毕，将构建数组指针后面的所有数置0【简单说就是，将数组中所有的非0数，按照相对顺序放到数组前面的位置，然后将后面的位置直接全部置为0。<strong>【对应下面方法1】</strong></p><p>第二种思路是使用<span class="label label-info">双指针</span>，<strong>左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</strong></p><p>右指针不断向右移动，<strong>每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</strong></p><p>注意到以下性质：</p><ol><li>左指针左边均为非零数；</li><li>右指针左边直到左指针处均为零。</li></ol><p>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的<strong>相对顺序并未改变。【对应下面方法2】</strong></p><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><h3 id="顺序遍历数组"><a href="#顺序遍历数组" class="headerlink" title="顺序遍历数组"></a>顺序遍历数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// 慢指针构建数组，快指针扫描非零数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; fast &lt; nums.length; fast++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] != <span class="hljs-number">0</span>) &#123;<br>            nums[slow] = nums[fast];<br>            slow++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 快指针遍历完后，将慢指针后的所有元素都置为零</span><br>    <span class="hljs-keyword">for</span> (; slow &lt; nums.length; slow++) &#123;<br>        nums[slow] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>        <span class="hljs-keyword">if</span> (nums[right] != <span class="hljs-number">0</span>) &#123;<br>            swap(nums, left, right); <span class="hljs-comment">// 将左指针的零与右指针的非零数交换</span><br>            left++;<br>        &#125;<br>        right++;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[left];<br>    nums[left] = nums[right];<br>    nums[right] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.最长连续序列</title>
    <link href="/2025/01/15/003-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
    <url>/2025/01/15/003-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h1><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[100,4,200,1,3,2]</span><br>输出：<span class="hljs-number">4</span><br>解释：最长数字连续序列是 <span class="hljs-string">[1, 2, 3, 4]</span>。它的长度为 <span class="hljs-number">4</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,3,7,2</span>,<span class="hljs-number">5,8,4,6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><div class="note note-primary">            <p>核心思想：使用set完成去重以及快速查找一个值是否存在</p>          </div><p>利用 <code>HashSet</code> 的特性，对于每个元素，<strong>如果它是一个连续序列的起始元素（即它的前一个元素不在集合中）</strong>，就计算从它开始的连续序列长度。通过遍历和检查元素及其相邻元素是否在集合中，找到最长的连续序列长度。</p><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    <span class="hljs-comment">// 使用set去重</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        set.add(num);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">longestStreak</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 最长序列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : set) &#123;<br>        <span class="hljs-keyword">if</span> (!set.contains(num - <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// 如果num-1不在集合中，则以他为序列第一个元素，判断最长序列</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">currentNum</span> <span class="hljs-operator">=</span> num;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currentStreak</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (set.contains(currentNum + <span class="hljs-number">1</span>)) &#123;<br>                currentNum += <span class="hljs-number">1</span>;<br>                currentStreak += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 更新最长序列长度</span><br>            longestStreak = Math.max(longestStreak, currentStreak);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> longestStreak;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.字母异位词分组</title>
    <link href="/2025/01/15/002-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"/>
    <url>/2025/01/15/002-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h1><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>核心点在于如何判断是否是字母异位词，我们可以从字母异位词的结构入手，发现每个字母异位词中的每个字符 出现的次数都是一样的，只是顺序不一样，这里有两种实现思路：</p><ol><li>自定义一个ArrayKey类型，专门用于判断是否是字母异位词，原理是，在ArrayKey中维护一个长度位26的数组，每一位存放一个字母出现的个数，在有参构造中，拿到字符串后，遍历每个字符，将对应的索引处的元素加一，重写ArrayKey的equals和hashCode方法，即可实现通过数组比较是否是字母异位词（如果是字母异位词，那么肯定有相同的数组，因为每个字符出现的次数都一样）</li><li>第二种方法是基于排序的，既然字母异位词只是字符排列不相同的单词，那么我们可以将每个单词都进行一个排序，这样，如果是字母异位词，那么排序后的字符串一定都相等，实现上就是先将字符串转换为字符数组，然后使用Arrays.sort方法对字符数组进行排序后，再转回字符串，如果排序后的字符串相同，肯定是字母异位词</li></ol><p>判断字母是不是异位词的问题解决后，我们就可以通过异位词判断之前是否添加过该异位词对于的列表，如果没有，则创建新的列表放入map中，如果有，则取旧的列表，直接将当前字符串添加到列表中即可</p><div class="note note-primary">            <p>map的key表示可以判断是否是字母异位词的结构，方法一是一个ArrayKey对象，方法二则是排序后的字符串</p><p>map的value则是当前类型的字母异位词对应的存放原字符串的列表</p>          </div><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_2_groupAnagrams</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过一个数组判定字母异位词</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayKey</span> &#123;<br>        <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object object)</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == object) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (object == <span class="hljs-literal">null</span> || getClass() != object.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">ArrayKey</span> <span class="hljs-variable">arrayKey</span> <span class="hljs-operator">=</span> (ArrayKey) object;<br>            <span class="hljs-keyword">return</span> Objects.deepEquals(array, arrayKey.array);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> Arrays.hashCode(array);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayKey</span><span class="hljs-params">(String str)</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> str.charAt(i);<br>                array[c - <span class="hljs-number">97</span>]++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        HashMap&lt;ArrayKey, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-comment">// 字母异位词的ArrayKey一定相同</span><br>            <span class="hljs-type">ArrayKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayKey</span>(str);<br>            List&lt;String&gt; list = map.computeIfAbsent(key, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>            list.add(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.values());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 所有的字母异位词排序后都一样</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> strs</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>    <span class="hljs-comment">// 「key:排序后的字母异位词，value:所有的字母异位词」</span><br>    HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>        <span class="hljs-comment">// 转字符数组</span><br>        <span class="hljs-type">char</span>[] charArray = str.toCharArray();<br>        <span class="hljs-comment">// 排序</span><br>        Arrays.sort(charArray);<br>        <span class="hljs-comment">// 转字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> Arrays.toString(charArray);<br>        <span class="hljs-comment">// 存在则返回链表，不存在则创建新的链表</span><br>        List&lt;String&gt; list = map.computeIfAbsent(string, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>        list.add(str);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(map.values());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.两数之和</title>
    <link href="/2025/01/15/001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2025/01/15/001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h1><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong><br>整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。</p><p>你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,4]</span>, target = 6<br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,3]</span>, target = 6<br>输出：<span class="hljs-comment">[0,1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p><strong>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</strong></p><p>本题呢，我就<strong>需要一个集合来存放我们遍历过的元素</strong>，然后在遍历数组的时候去询问这个集合，<strong>某元素是否遍历过，也就是<br>是否出现在这个集合。</strong></p><p>那么我们就应该想到使用哈希法了。</p><p>因为本题，<strong>我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标</strong>，需要使用 key value结构来存放，<span class="label label-info"> key来存元素，value来存下标</span>，那么使用map正合适。</p><p>再来看一下使用数组和set来做哈希法的局限。</p><ul><li><strong>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费</strong>。</li><li><strong>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和<br>y的下标。所以set 也不能用</strong>。</li></ul><p>此时就要选择另一种数据结构：map ，map是一种key — value的存储结构，<strong>可以用key保存数值，用value再保存数值所在的下标</strong>。</p><p><img src="/img/post/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.assets/image-20250115195537832.png" alt="两数之和"></p><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">_001_twoSum</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">// 「key:数组元素  value：元素对应数组下标」</span><br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>            <span class="hljs-keyword">if</span> (map.containsKey(target - num)) &#123;<br>                <span class="hljs-comment">// 如果map中存了和当前元素配对的元素，直接取下标返回</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i, map.get(target - num)&#125;;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 否则将当前元素放入map</span><br>                map.put(num, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>hot100算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL之窗口函数</title>
    <link href="/2025/01/09/SQL%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    <url>/2025/01/09/SQL%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><blockquote><p>先说定义：「<strong>看完定义你可能觉得一头雾水，哈哈别急，等我后续一步步拆解</strong>」窗口函数是 SQL 中一种用于在查询结果集的特定 “窗口”（子集）上进行计算的函数。它能够在不改变原始数据行的基础上，为每行数据计算出一个聚合值或排名值等相关结果。与普通聚合函数（如 SUM、AVG 等）不同，聚合函数会将多行数据聚合成一行输出，而窗口函数可以在每一行数据上都返回一个计算结果。</p></blockquote><p><img src="/img/post/SQL%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0.assets/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E4%B8%8E%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="窗口函数与聚合函数的区别" title="窗口函数与聚合函数的区别"></p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">function</span>(args) <span class="hljs-keyword">OVER</span>([<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> expression] [<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> expression[<span class="hljs-keyword">ASC</span><span class="hljs-operator">|</span><span class="hljs-keyword">DESC</span>]][frame])<br></code></pre></td></tr></table></figure><p>表达式拆解：</p><p>首先，OVER，PARTITION BY，ORDER BY 都是关键字，记住就好啦，之后越用越习惯，我们主要来拆解一下他们的作用</p><h4 id="1）function-args"><a href="#1）function-args" class="headerlink" title="1）function(args)"></a>1）<code>function(args)</code></h4><p>这个函数的作用就是在指定窗口中对数据进行计算或处理，以得出所需的结果。「至于这里说的窗口是什么，请往下看」</p><p><code>function(args)</code>可以是聚合函数，也可以是排名函数，具体使用什么函数就和不同的业务相关了，我在这里列出几个常用的函数：</p><p><strong>聚合函数</strong>：</p><ul><li><strong>SUM(args)</strong>：计算分区内指定列的总和。「这里的分区和窗口是一个概念，以下同理」</li><li><strong>AVG(args)</strong>：计算分区内指定列的平均值。</li><li><strong>MIN(args)</strong>：找出分区内指定列的最小值。</li><li><strong>MAX(args)</strong>：找出分区内指定列的最大值。</li></ul><p><strong>排名函数</strong>：</p><ul><li><strong>RANK()</strong>：为分区内的行分配排名，相同的值会获得相同的排名，并且会跳过相同排名的数量。</li><li><strong>DENSE_RANK()</strong>：为分区内的行分配排名，相同的值会获得相同的排名，但不会跳过相同排名的数量。</li><li><strong>ROW_NUMBER()</strong>：为分区内的行分配一个唯一的连续整数，从 1 开始，无论行内的值是否相同。（关于这三个排名函数的区别，下面会详细介绍➕做题练习）</li></ul><h4 id="2）-PARTITION-BY-expression"><a href="#2）-PARTITION-BY-expression" class="headerlink" title="2）[PARTITION BY expression]"></a>2）<code>[PARTITION BY expression]</code></h4><p><code>[PARTITION BY expression]</code>其中，PARTITION BY 是关键字，记住即可，而后面的 expression，就是我们要指定一个分组，这个字段通俗理解就是，我们要按照什么进行分组，当然他是<strong>可选的</strong></p><h4 id="3）-ORDER-BY-expression-ASC-DESC"><a href="#3）-ORDER-BY-expression-ASC-DESC" class="headerlink" title="3）[ORDER BY expression[ASC|DESC]]"></a>3）<code>[ORDER BY expression[ASC|DESC]]</code></h4><p>ORDER BY 就好理解了，就是要指定我们要按照什么进行排序，默认是升序，如果要降序排序，需要我们进行显示的指定</p><h4 id="4）-frame"><a href="#4）-frame" class="headerlink" title="4）[frame]"></a>4）<code>[frame]</code></h4><p>最后一部分就是这个<code>[frame]</code>了，他其实是指定一个窗口大小，也是可选的，其中他又分为两种模式，分别是<code>ROWS BETWEEN</code>和<code>RANGE BETWEEN</code>，下面我们来简单说一下这两种模式的区别：</p><p><code>ROWS BETWEEN</code>：按物理行来进行划分窗口，明确指定了窗口包含的行数，从当前行开始，向前或向后延伸一定的行数。</p><ul><li><code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>：窗口从分区的第一行开始，到当前行结束。</li><li><code>ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING</code>：窗口包含当前行的<strong>前一行、当前行和后一行</strong>，总共三行。</li></ul><p><code>RANGE BETWEEN</code>：按一定的数值逻辑来划分窗口范围，该范围是根据 <code>ORDER BY</code> 子句中列的值的范围来确定的，而不是物理行。通常与 <code>ORDER BY</code> 子句中的排序字段的逻辑值范围相关。</p><ul><li><code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>：窗口包含从分区的第一行开始，到当前行**（基于** <code>ORDER BY</code> **列的值）**的所有行。</li><li><code>RANGE BETWEEN 5 PRECEDING AND 5 FOLLOWING</code>：窗口包含 <code>ORDER BY</code> 列的值<strong>在当前行的值的前 5 个值到后 5 个值之间的所有行</strong>，而不是具体的物理行。</li></ul><p><strong>关键区别总结</strong>：</p><ul><li><code>ROWS BETWEEN</code> 基于<strong>物理行</strong>，根据实际的行位置来确定窗口范围，对于需要精确控制前后行数量的计算（如移动平均、相邻行对比等）很有用。</li><li><code>RANGE BETWEEN</code> 基于<strong>逻辑范围</strong>，根据 <code>ORDER BY</code> 列的<strong>值</strong>的范围来确定窗口范围，更适合处理需要根据排序字段的值的范围进行计算的情况，例如基于数据值范围的聚合计算，对数据的逻辑分组和分析更有帮助。</li></ul><p>大家注意体会上述的<strong>物理行</strong>与<strong>逻辑值</strong>的关系~~~</p><p>针对<code>[frame]</code>，我再列出一些他的常用表达式和对应的含义，大家可以对照着看看，一定可以理解~</p><p><code>ROWS BETWEEN</code> <strong>常用表达式</strong>：</p><ul><li><code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>：分区范围为从起始行到当前行</li><li><code>ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING</code>：分区范围为从当前行到最后一行</li><li><code>ROWS BETWEEN n PRECEDING AND m FOLLOWING</code>：从当前行的前 <code>n</code> 行开始，到当前行的后 <code>m</code> 行结束</li></ul><p><code>RANGE BETWEEN</code> <strong>常用表达式</strong>：</p><ul><li><code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>：此窗口范围从该分区中<strong>排序字段</strong>最小的行开始，到当前行结束。</li></ul><p><code>RANGE BETWEEN</code> <strong>的表达式不好理解，我们举一个具体的例子来看：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    product_id, <br>    sales_date, <br>    sales_amount, <br>    <span class="hljs-built_in">SUM</span>(sales_amount) <span class="hljs-keyword">OVER</span> (<br>        <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> product_id <br>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sales_date <br>        <span class="hljs-keyword">RANGE</span> <span class="hljs-keyword">BETWEEN</span> UNBOUNDED PRECEDING <span class="hljs-keyword">AND</span> <span class="hljs-keyword">CURRENT</span> <span class="hljs-type">ROW</span><br>    ) <span class="hljs-keyword">AS</span> cumulative_sales_amount<br><span class="hljs-keyword">FROM</span> <br>    sales;<br></code></pre></td></tr></table></figure><p><strong>解释</strong>：对于每个 <code>product_id</code> 分区，按 <code>sales_date</code> 排序。此窗口范围从该分区中 <code>sales_date</code> 最小的行开始，到当前行（根据 <code>sales_date</code> 的值）结束。<code>cumulative_sales_amount</code> 计算的是从该分区中 <code>sales_date</code> 最小的行到当前行的 <code>sales_amount</code> 的累计和。<strong>它会考虑</strong> <code>sales_date</code> <strong>值小于或等于当前行</strong> <code>sales_date</code> <strong>的所有行，而不是具体的行数。</strong></p><ul><li><code>RANGE BETWEEN n PRECEDING AND m FOLLOWING</code>：此窗口范围包括 <code>sales_date</code> 值在当前行 <code>sales_date</code> 减去 <code>n</code>（这里 <code>n = 10</code>）到当前行 <code>sales_date</code> 加上 <code>m</code>（这里 <code>m = 10</code>）范围内的所有行。</li></ul><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    product_id, <br>    sales_date, <br>    sales_amount, <br>    <span class="hljs-built_in">AVG</span>(sales_amount) <span class="hljs-keyword">OVER</span> (<br>        <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> product_id <br>        <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> sales_date <br>        <span class="hljs-keyword">RANGE</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">10</span> PRECEDING <span class="hljs-keyword">AND</span> <span class="hljs-number">10</span> FOLLOWING<br>    ) <span class="hljs-keyword">AS</span> range_average<br></code></pre></td></tr></table></figure><p><strong>解释</strong>：对于每个 <code>product_id</code> 分区，按 <code>sales_date</code> 排序。此窗口范围包括 <code>sales_date</code> 值在当前行 <code>sales_date</code> 减去 <code>n</code>（这里 <code>n = 10</code>）到当前行 <code>sales_date</code> 加上 <code>m</code>（这里 <code>m = 10</code>）范围内的所有行。<code>range_average</code> 计算的是这些行的 <code>sales_amount</code> 的平均值。请注意，这里的范围是基于 <code>sales_date</code> 的值，而不是物理行，因此如果有多个行的 <code>sales_date</code> 在这个范围内，它们都会被考虑进去。</p><h3 id="排序函数的区别"><a href="#排序函数的区别" class="headerlink" title="排序函数的区别"></a>排序函数的区别</h3><p><img src="/img/post/SQL%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0.assets/1736386648048-781ff4fd-4d1a-44a8-a8ea-95cd9bca241a.jpeg" alt="三大排序函数的区别" title="三大排序函数的区别"></p><p><strong>函数记忆关键点：</strong></p><ul><li><code>row_number()</code>：序号不重复且连续</li><li><code>rank()</code>：序号可以重复，但序号不连续（比如：两个同学成绩都是 100 并列第一，第三个同学排名就是第三）</li><li><code>dense_rank()</code>：序号可以重复，序号连续</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>LeetCode <a href="https://leetcode.cn/problems/rank-scores/">178. 分数排名</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>  Scores.score,<br>  <span class="hljs-comment">-- 使用 DENSE_RANK() 窗口函数对成绩进行排名</span><br>  <span class="hljs-comment">-- 该函数会为结果集中的每一行分配一个排名，根据分数降序排列</span><br>  <span class="hljs-comment">-- 相同分数的行将获得相同的排名，并且排名不会跳过，即下一个不同分数的排名会紧挨着上一个不同分数的排名</span><br>  <span class="hljs-built_in">dense_rank</span>() <span class="hljs-keyword">over</span> (<br>    <span class="hljs-comment">-- 按照分数降序排列</span><br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>      score <span class="hljs-keyword">DESC</span><br>  ) <span class="hljs-keyword">AS</span> `rank`<br><span class="hljs-keyword">FROM</span><br>  Scores;<br></code></pre></td></tr></table></figure><p>LeetCode <a href="https://leetcode.cn/problems/department-highest-salary/">184. 部门工资最高的员工</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>  Department,<br>  Employee,<br>  Salary<br><span class="hljs-keyword">from</span><br>  (<br>    <span class="hljs-keyword">select</span><br>      d.name <span class="hljs-keyword">as</span> Department,<br>      e.name <span class="hljs-keyword">as</span> Employee,<br>      e.salary <span class="hljs-keyword">as</span> Salary,<br>      <span class="hljs-comment">-- 窗口函数，根据部门ID分组后再根据员工薪水降序排序的顺序进行排名</span><br>      <span class="hljs-built_in">rank</span>() <span class="hljs-keyword">over</span> (<br>        <span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span><br>          e.departmentId<br>        <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span><br>          e.salary <span class="hljs-keyword">desc</span><br>      ) <span class="hljs-keyword">as</span> salary_rank<br>    <span class="hljs-keyword">from</span><br>      Employee <span class="hljs-keyword">as</span> e<br>      <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> Department <span class="hljs-keyword">as</span> d <span class="hljs-keyword">on</span> e.departmentId <span class="hljs-operator">=</span> d.id<br>  ) <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">where</span><br>  <span class="hljs-comment">-- 取排名为1的员工就是部门最高薪水的员工</span><br>  salary_rank <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看到这里，再来回看一下窗口函数的定义：</p><p>窗口函数是 SQL 中一种用于在查询结果集的特定 “窗口”（子集）上进行计算的函数。它能够在不改变原始数据行的基础上，为每行数据计算出一个聚合值或排名值等相关结果。与普通聚合函数（如 SUM、AVG 等）不同，聚合函数会将多行数据聚合成一行输出，而窗口函数可以在每一行数据上都返回一个计算结果。</p><p>已经很清晰啦~~</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>SQL</tag>
      
      <tag>窗口函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2025/01/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>偷个懒先传个PDF上来 ~~ 有需要可以下载下来看</p></blockquote><div class="row">    <embed src="/pdf/排序算法.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
      <tag>十大排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HelloWorld ~</title>
    <link href="/2025/01/07/hello-world/"/>
    <url>/2025/01/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>都和你说了什么都没有，真的什么都没有</p>]]></content>
    
    
    <categories>
      
      <category>博文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>我的第一篇博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
