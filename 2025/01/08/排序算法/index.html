

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/outer/logo.png">
  <link rel="icon" href="/img/outer/logo.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="hexo, blog, fluid theme, personal blog">
  
    <meta name="description" content="引言 排序算法（**sorting algorithm**）是用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。  如图所示，排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则。   排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法">
<meta property="og:url" content="http://example.com/2025/01/08/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Ovo&#39;s Blog">
<meta property="og:description" content="引言 排序算法（**sorting algorithm**）是用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。  如图所示，排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则。   排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713702653902-88d69fae-fd96-4b5d-be7c-32844a293103.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713703118754-f15ec1cd-3e07-42a3-8def-ff1d8b6cbce3.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713704110413-a56b79e5-3540-4e15-b4c2-4b3678f8a0b5.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713704714978-03071c53-038d-4fde-9a77-1cf1a982a77f.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713705563461-9b8095a8-925a-45f1-8915-0d46e43c1b3c.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713761185031-e3d192b0-1fae-4081-ba67-5b633906d84e.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713761184921-3529b4dc-765c-42a0-8056-635fdbb82a3b.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713764474297-d9a5b25b-f3cf-41fa-8733-49c35520ead4.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/40730112/1713860353697-d29b7801-fde6-4e0e-9e3b-c19eee5efdca.jpeg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/40730112/1713860389510-21c544cc-0598-47c4-b132-100af8745c59.jpeg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/40730112/1713860578845-542d4516-0ae4-4173-8bbb-4d3553fa4b7a.jpeg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713861162759-548ab726-b7b7-4bc5-99fe-e8779f698bfe.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/40730112/1713861735521-4b2185f8-c0d8-484a-93a5-78a32d8b6013.jpeg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/gif/40730112/1713861786160-9cb8e332-91f7-4c1b-a094-17b247c7374c.gif">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/gif/40730112/1713862301842-71cfd622-a543-46d3-95b0-5f5cd9da37e0.gif">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/40730112/1713861861363-ec10d9f2-7b6c-4228-812e-3e6298f56cb7.jpeg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/jpeg/40730112/1713862059883-ccac732a-7606-468f-98a5-3d025ce140be.jpeg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713939661537-0690c2f0-6c54-4cbc-ad1c-fe75baafded6.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713939674764-df5f7aee-8624-4fba-98f4-fd1670b5108a.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713939763311-4d8e1c6c-a771-4874-a639-90bd0c1be074.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940443983-0808c12f-43af-4dad-ad0f-9c5808a222f3.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940440974-43bf6ded-6835-4da2-85f6-51c07572a51d.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940436983-49897f44-e025-4a7c-875e-40506bbb8bcb.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940433562-635834c6-963a-4e1d-a3b8-ad6d1fc486d4.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940419785-830b65cb-5cda-46f8-bb45-1b81c2f67484.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940411107-149c3e22-bb5f-44de-9f63-b8782f68fb5f.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940998181-53b30a13-4fea-48eb-a732-87d78cbffaa2.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713945792665-c4280330-ddc5-4f4d-842c-20372503fed2.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713945830029-aeff3220-9fa6-4191-94bc-1154ba03e2d9.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713945840461-da92a973-9aff-42ce-9967-27fb521601bc.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713945962154-22998e8f-1e61-411f-988e-a8fc01082318.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713945969555-b11b9652-fe8b-472e-a0f7-0abd6b7a8259.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713945976129-27677173-9db7-4b75-9ccc-257a2fb8aacb.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713946141870-c2307dac-c7f9-4641-994e-165dbd9b021f.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713946270491-276cc0a5-168d-4655-af67-53c2361565aa.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034222739-60b40e6b-64b1-495c-a668-80798112bd81.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034228904-690d0fe9-7b30-48ce-a610-aff18661d46b.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034241328-bf95dbf9-509c-421d-a270-534102cb1f8f.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034243415-b2733349-93aa-4eab-bd10-721dab665562.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034245611-85448aed-4611-4366-945d-d7f6a5fac143.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034248903-1b9d95e0-a962-42cf-ad8c-532530889672.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034252757-973e0d98-60d9-4f85-9751-45e2669bd05d.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034257715-798fbb4d-89ec-43c6-b198-c4dea55faf3e.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034262409-98a52a34-b7de-4536-b48f-4b74ffed9207.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034269010-bc3e8a7c-66c4-4d07-8b21-6825e5620ea0.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034271915-ef40ea7f-5ee9-4b32-b612-7b22bd7ccc2e.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034274565-666a6742-27a4-45e4-a621-a30d4444505e.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714361611552-64455a6c-b48e-4426-8ca0-892c787f4a5b.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379493320-e1596c3c-dace-4fc1-87ba-b8cfc31d703a.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379497443-ed2c6598-c7cc-4b08-bd41-f2467da12a40.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379510439-1fecd667-ce0d-422a-a8e6-6d1013c7827e.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379513809-258216d3-9de2-4a6b-8810-a355bc7eeaca.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379516309-fe4bf782-e113-4566-94c7-589495144202.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379520702-3b7f0245-7445-424d-908c-317de1cb7c44.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379523336-d82ba0d5-0916-488a-bc63-7ca31ab9bff9.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379526923-0242d20f-8aef-40f0-8bba-cc6b98ca743a.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714383034696-27b1204d-2a2d-4bb4-bcf5-6f101d676bd6.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714384908781-62c4e1f6-86cf-4e7f-bd2a-d0dacf12da92.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714384908705-8eddc37d-88a7-4046-9767-b34742ebf4ff.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714463575538-0ba43ec3-91c7-4347-9e76-2bb43f23c51e.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714466061550-c37ba78e-e921-48b7-902c-c8ccf966aad1.png">
<meta property="article:published_time" content="2025-01-08T07:04:14.000Z">
<meta property="article:modified_time" content="2025-01-08T07:05:01.369Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="hexo, blog, fluid theme, personal blog">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713702653902-88d69fae-fd96-4b5d-be7c-32844a293103.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>排序算法 - Ovo&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ovo&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/example.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="排序算法"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-01-08 15:04" pubdate>
          2025年1月8日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          165 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">排序算法</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    <!-- compatible with older versions-->
                    本文最后更新于：2025-01-08T15:05:01+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="ScaSH"><font style="color:rgb(29, 29, 32);">引言</font></h1>
<font style="color:rgb(29, 29, 32);">排序算法（</font>**<font style="color:rgb(29, 29, 32);">sorting algorithm</font>**<font style="color:rgb(29, 29, 32);">）是用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。</font>

<p><font style="color:rgb(29, 29, 32);">如图所示，排序算法中的数据类型可以是</font><strong><font style="color:rgb(29, 29, 32);">整数、浮点数、字符</font></strong><font style="color:rgb(29, 29, 32);">或</font><strong><font style="color:rgb(29, 29, 32);">字符串</font></strong><font style="color:rgb(29, 29, 32);">等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713702653902-88d69fae-fd96-4b5d-be7c-32844a293103.png" srcset="/img/loading.gif" lazyload alt="数据类型和判断规则示例"></p>
<p><font style="color:rgb(44, 62, 80);"></font></p>
<p><font style="color:rgb(44, 62, 80);">排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。</font></p>
<p><font style="color:rgb(51, 51, 51);">排序算法可以分为</font><strong><font style="color:#ED740C;">内部排序</font></strong><font style="color:rgb(51, 51, 51);">和</font><strong><font style="color:#ED740C;">外部排序</font></strong><font style="color:rgb(51, 51, 51);">，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的排序算法有：</font><strong><font style="color:rgb(51, 51, 51);">插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序</font></strong><font style="color:rgb(51, 51, 51);">等。</font></p>
<p><font style="color:rgb(51, 51, 51);">用一张图概括：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713703118754-f15ec1cd-3e07-42a3-8def-ff1d8b6cbce3.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="QOrGA"><font style="color:rgb(51, 51, 51);">关于时间复杂度</font></h2>
<font style="color:rgb(51, 51, 51);">时间复杂度用来衡量一个算法的运行时间和输入规模的关系，通常用 </font>_<font style="color:rgb(51, 51, 51);">O </font>_<font style="color:rgb(51, 51, 51);">表示。</font>

<p><font style="color:rgb(51, 51, 51);">简单计算复杂度的方法一般是统计</font><strong><font style="color:#ED740C;">「简单操作」</font></strong><font style="color:rgb(51, 51, 51);">的执行次数，有时候也可以直接数循环的层数来近似估计。基于比较的排序算法的时间复杂度下限是 </font><em><font style="color:rgb(51, 51, 51);">O(nlogn) </font></em><font style="color:rgb(51, 51, 51);">的。当然也有不是 </font><em><font style="color:rgb(51, 51, 51);">O(nlogn) </font></em><font style="color:rgb(51, 51, 51);">的。例如，计数排序的时间复杂度是 </font><em><font style="color:rgb(51, 51, 51);">O(n + w) </font></em><font style="color:rgb(51, 51, 51);">，其中 w 代表输入数据的值域大小。</font></p>
<p><font style="color:rgb(51, 51, 51);"></font></p>
<ol>
<li><font style="color:rgb(51, 51, 51);">平方阶 </font><strong><font style="color:rgb(51, 51, 51);">O(n</font></strong><sup><strong><font style="color:rgb(51, 51, 51);">2</font></strong></sup><strong><font style="color:rgb(51, 51, 51);">)</font></strong><font style="color:rgb(51, 51, 51);"> 排序 各类简单排序：</font><strong><font style="color:rgb(51, 51, 51);">直接插入</font></strong><font style="color:rgb(51, 51, 51);">、</font><strong><font style="color:rgb(51, 51, 51);">直接选择</font></strong><font style="color:rgb(51, 51, 51);">和</font><strong><font style="color:rgb(51, 51, 51);">冒泡排序</font></strong><font style="color:rgb(51, 51, 51);">。</font></li>
<li><font style="color:rgb(51, 51, 51);">线性对数阶 </font><strong><font style="color:rgb(51, 51, 51);">O(nlog</font></strong><sub><strong><font style="color:rgb(51, 51, 51);">2</font></strong></sub><strong><font style="color:rgb(51, 51, 51);">n)</font></strong><font style="color:rgb(51, 51, 51);"> 排序 </font><strong><font style="color:rgb(51, 51, 51);">快速排序</font></strong><font style="color:rgb(51, 51, 51);">、</font><strong><font style="color:rgb(51, 51, 51);">堆排序</font></strong><font style="color:rgb(51, 51, 51);">和</font><strong><font style="color:rgb(51, 51, 51);">归并排序</font></strong><font style="color:rgb(51, 51, 51);">；</font></li>
<li><font style="color:rgb(51, 51, 51);">O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 </font><strong><font style="color:rgb(51, 51, 51);">希尔排序</font></strong></li>
<li><font style="color:rgb(51, 51, 51);">线性阶 (O(n)) 排序 </font><strong><font style="color:rgb(51, 51, 51);">基数排序</font></strong><font style="color:rgb(51, 51, 51);">，此外还有</font><strong><font style="color:rgb(51, 51, 51);">桶</font></strong><font style="color:rgb(51, 51, 51);">、</font><strong><font style="color:rgb(51, 51, 51);">箱排序</font></strong><font style="color:rgb(51, 51, 51);">。</font></li>
</ol>
<h2 id="NglTf"><font style="color:rgba(0, 0, 0, 0.87);">关于空间复杂度</font></h2>
<font style="color:rgb(51, 51, 51);">与时间复杂度类似，空间复杂度用来描述算法空间消耗的规模。一般来说，空间复杂度越小，算法越好。</font>

<h2 id="GVSsV"><font style="color:rgb(51, 51, 51);">关于稳定性</font></h2>
**<font style="color:rgb(51, 51, 51);background-color:#FBDE28;">稳定性是指相等的元素经过排序之后相对顺序是否发生了改变。</font>**

<p><font style="color:rgb(51, 51, 51);">拥有稳定性这一特性的算法会让原本有相等键值的纪录维持相对次序，即如果一个排序算法是稳定的，当有两个相等键值的纪录 A 和 B，且</font><strong><font style="color:rgb(51, 51, 51);background-color:#FBDE28;">在原本的列表中 A 出现在 B 之前，在排序过的列表中 A 也将会是在 B 之前。</font></strong></p>
<ul>
<li><strong><font style="color:rgb(44, 62, 80);">稳定</font></strong><font style="color:rgb(44, 62, 80);">：如果 A 原本在 B 前面，而 𝐴&#x3D;𝐵，排序之后 A 仍然在 B 的前面。</font></li>
<li><strong><font style="color:rgb(44, 62, 80);">不稳定</font></strong><font style="color:rgb(44, 62, 80);">：如果 A 原本在 B 的前面，而 𝐴&#x3D;𝐵，排序之后 A 可能会出现在 B 的后面。</font></li>
</ul>
<p>:::success<br>👍**<font style="color:rgb(51, 51, 51);"> 稳定的排序算法：</font>**<font style="color:rgb(51, 51, 51);">冒泡排序、 插入排序、归并排序、计数排序和基数排序。</font></p>
<p>🖐️ <strong><font style="color:rgb(51, 51, 51);">不是稳定的排序算法：</font></strong><font style="color:rgb(51, 51, 51);">选择排序、快速排序、希尔排序、堆排序。</font></p>
<p>:::</p>
<h2 id="jMq6a"><font style="color:rgb(51, 51, 51);">名词解释</font></h2>
**<font style="color:rgb(51, 51, 51);">n</font>**<font style="color:rgb(51, 51, 51);">：数据规模</font>

<p><strong><font style="color:rgb(51, 51, 51);">k</font></strong><font style="color:rgb(51, 51, 51);">：“桶”的个数</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">In-place</font></strong><font style="color:rgb(51, 51, 51);">：占用常数内存，不占用额外内存</font></p>
<p><strong><font style="color:rgb(51, 51, 51);">Out-place</font></strong><font style="color:rgb(51, 51, 51);">：占用额外内存</font></p>
<h2 id="cTSlz"><font style="color:rgb(29, 29, 32);">理想排序算法</font></h2>
**<font style="color:rgb(29, 29, 32);">运行快、原地、稳定、正向自适应、通用性好</font>**<font style="color:rgb(29, 29, 32);">。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定。</font>

<p><font style="color:rgb(29, 29, 32);">接下来，我们将共同学习各种排序算法，并基于上述评价维度对各个排序算法的优缺点进行分析。</font></p>
<p><font style="color:rgb(51, 51, 51);"></font></p>
<h2 id="tO3eX"><font style="color:rgb(51, 51, 51);">算法分类</font></h2>
<font style="color:rgb(44, 62, 80);">十种常见排序算法可以分类两大类别：</font>**<font style="color:#117CEE;">比较类排序（7 个）</font>**<font style="color:rgb(44, 62, 80);">和</font>**<font style="color:#117CEE;">非比较类排序（3 个）</font>**<font style="color:rgb(44, 62, 80);">。</font>

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713704110413-a56b79e5-3540-4e15-b4c2-4b3678f8a0b5.png" srcset="/img/loading.gif" lazyload alt="排序算法分类"></p>
<p><font style="color:rgb(29, 29, 32);">常见的</font><strong><font style="color:rgb(29, 29, 32);">快速排序</font></strong><font style="color:rgb(29, 29, 32);">、</font><strong><font style="color:rgb(29, 29, 32);">归并排序</font></strong><font style="color:rgb(29, 29, 32);">、</font><strong><font style="color:rgb(29, 29, 32);">堆排序</font></strong><font style="color:rgb(29, 29, 32);">以及</font><strong><font style="color:rgb(29, 29, 32);">冒泡排序</font></strong><font style="color:rgb(29, 29, 32);">等都属于</font><strong><font style="color:#117CEE;">比较类排序算法</font></strong><font style="color:rgb(29, 29, 32);">。比较类排序是通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 </font><em><font style="color:rgb(29, 29, 32);">O(nlogn)</font></em><font style="color:rgb(29, 29, 32);">，因此也称为</font><strong><font style="color:#ED740C;">非线性时间比较类排序。</font></strong></p>
<p><font style="color:rgb(29, 29, 32);">在冒泡排序之类的排序中，问题规模为 n，又因为需要比较 n 次，所以平均时间复杂度为 </font><em><font style="color:rgb(29, 29, 32);">O(n²)</font></em><font style="color:rgb(29, 29, 32);">。在归并排序、快速排序之类的排序中，问题规模通过</font><strong><font style="color:rgb(29, 29, 32);">分治法</font></strong><font style="color:rgb(29, 29, 32);">消减为 log n 次，所以时间复杂度平均 </font><em><font style="color:rgb(29, 29, 32);">O(nlogn)</font></em><font style="color:rgb(29, 29, 32);">。</font></p>
<p><font style="color:rgb(29, 29, 32);">比较类排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。</font><strong><font style="color:rgb(29, 29, 32);">可以说，比较排序适用于一切需要排序的情况。</font></strong></p>
<p><font style="color:rgb(29, 29, 32);">而</font><strong><font style="color:rgb(29, 29, 32);">计数排序</font></strong><font style="color:rgb(29, 29, 32);">、</font><strong><font style="color:rgb(29, 29, 32);">基数排序</font></strong><font style="color:rgb(29, 29, 32);">、</font><strong><font style="color:rgb(29, 29, 32);">桶排序</font></strong><font style="color:rgb(29, 29, 32);">则属于</font><strong><font style="color:#117CEE;">非比较类排序算法</font></strong><font style="color:rgb(29, 29, 32);">。非比较排序不通过比较来决定元素间的相对次序，而是</font><strong><font style="color:rgb(29, 29, 32);">通过确定每个元素之前应该有多少个元素来排序。</font></strong><font style="color:rgb(29, 29, 32);">由于它可以突破基于比较排序的时间下界，以线性时间运行，因此称为</font><strong><font style="color:#ED740C;">线性时间非比较类排序</font></strong><font style="color:#ED740C;">。</font><font style="color:rgb(29, 29, 32);"> 非比较排序只要确定每个元素之前的已有的元素个数即可，所以一次遍历即可解决。算法时间复杂度 O(n)。</font></p>
<p><font style="color:rgb(29, 29, 32);">非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置（典型的</font><strong><font style="color:#ED740C;">空间换时间</font></strong><font style="color:rgb(29, 29, 32);">思想）。所以对数据规模和数据分布有一定的要求。</font></p>
<hr>
<h1 id="eoDI0"><font style="color:rgb(51, 51, 51);">一：冒泡排序（Bubble Sort）</font></h1>
**<font style="color:#ED740C;">冒泡排序（Bubble Sort）</font>**<font style="color:rgb(51, 51, 51);">也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为最小的元素会经由交换慢慢“浮”到数列的顶端。</font>

<p><font style="color:rgb(51, 51, 51);">作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。</font><strong><font style="color:rgb(51, 51, 51);">冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。</font></strong><font style="color:rgb(51, 51, 51);">但这种改进对于提升性能来说并没有什么太大作用。</font></p>
<h2 id="NEfrF"><font style="color:rgb(51, 51, 51);">1. 算法步骤</font></h2>
:::success
1. <font style="color:rgb(51, 51, 51);">比较相邻的元素。如果第一个比第二个大，就交换他们两个。</font>
2. <font style="color:rgb(51, 51, 51);">对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</font>
3. <font style="color:rgb(51, 51, 51);">针对所有的元素重复以上的步骤，除了最后一个。</font>
4. <font style="color:rgb(51, 51, 51);">持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</font>

<p>:::</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713704714978-03071c53-038d-4fde-9a77-1cf1a982a77f.png" srcset="/img/loading.gif" lazyload alt="冒泡排序流程"></p>
<blockquote>
<p><strong><font style="color:#601BDE;">要点</font></strong> 💥</p>
<ul>
<li>每轮冒泡不断地比较<strong>相邻</strong>的两个元素，如果它们是逆序的，则交换它们的位置</li>
<li>下一轮冒泡，可以调整未排序的右边界，减少不必要比较</li>
</ul>
</blockquote>
<h2 id="TsXI4"><font style="color:rgb(51, 51, 51);">2. 动图演示</font></h2>
![冒泡排序](https://cdn.nlark.com/yuque/0/2024/gif/40730112/1713704515845-84450354-489d-46e6-8e9b-c08ffdb713d1.gif)

<h2 id="t3qLW"><font style="color:rgb(51, 51, 51);">3. 什么时候最快</font></h2>
<font style="color:rgb(51, 51, 51);">当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。</font>

<h2 id="XUFRX"><font style="color:rgb(51, 51, 51);">4. 什么时候最慢</font></h2>
<font style="color:rgb(51, 51, 51);">当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。</font>

<h2 id="Grt1k"><font style="color:rgb(51, 51, 51);">5. 代码实现</font>🎆</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] bubbleSort(<span class="hljs-type">int</span>[] nums) &#123;<br>  <span class="hljs-comment">// 未排序数据的右边界</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">//定义一个变量 x 记录未排序区域的右边界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>      <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 相邻元素中前面的元素大则交换</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>        nums[i] = nums[i + <span class="hljs-number">1</span>];<br>        nums[i + <span class="hljs-number">1</span>] = t;<br>        <span class="hljs-comment">// 每次交换后，更新变量x,最后一次交换后x的值为经过一轮排序后新的右边界，优化代码</span><br>        x = i;<br>      &#125;<br>    &#125;<br>    j = x;<br>  &#125; <span class="hljs-keyword">while</span> (j != <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//定义一个变量 x 记录未排序区域的右边界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &gt; nums[i + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 相邻元素中前面的元素大则交换</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>            nums[i] = nums[i + <span class="hljs-number">1</span>];<br>            nums[i + <span class="hljs-number">1</span>] = t;<br>            <span class="hljs-comment">// 每次交换以后，更新x &lt;未排序数据的右边界&gt; 的值</span><br>            x = i;<br>        &#125;<br>    &#125;<br>    bubbleSort(nums, x);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] bubbleSort(<span class="hljs-type">int</span>[] arr) &#123;<br>    <span class="hljs-comment">// 数组长度如果为5，则需要进行4轮冒泡</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">// 相邻元素中前面的元素大则交换</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[j];<br>                arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                arr[j + <span class="hljs-number">1</span>] = tmp;<br>                <span class="hljs-comment">// Change flag 只要一轮循环发生了交换，则把flag置为false</span><br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 一轮都没有发生交换，没必要继续，直接退出循环</span><br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><font style="color:rgb(44, 62, 80);">此处对代码做了一个小优化，加入了 </font></strong><code>**&lt;font style=&quot;color:rgb(44, 62, 80);&quot;&gt;is_sorted&lt;/font&gt;**</code><strong><font style="color:rgb(44, 62, 80);"> Flag，目的是将算法的最佳时间复杂度优化为 O(n)，即当原输入序列就是排序好的情况下，该算法的时间复杂度就是 O(n)。</font></strong></p>
<h2 id="cY8rm">6. 算法分析</h2>
+ **<font style="color:rgb(44, 62, 80);">稳定性</font>**<font style="color:rgb(44, 62, 80);">：稳定</font>
+ **<font style="color:rgb(44, 62, 80);">时间复杂度</font>**<font style="color:rgb(44, 62, 80);">：最佳：𝑂(𝑛) ，最差：𝑂(𝑛</font><sup><font style="color:rgb(44, 62, 80);">2</font></sup><font style="color:rgb(44, 62, 80);">)， 平均：𝑂(𝑛</font><sup><font style="color:rgb(44, 62, 80);">2</font></sup><font style="color:rgb(44, 62, 80);">)</font>
+ **<font style="color:rgb(44, 62, 80);">空间复杂度</font>**<font style="color:rgb(44, 62, 80);">：𝑂(1)</font>
+ **<font style="color:rgb(44, 62, 80);">排序方式</font>**<font style="color:rgb(44, 62, 80);">：In-place</font>

<hr>
<h1 id="SEoaV"><font style="color:rgb(51, 51, 51);">二：选择排序 (Selection Sort)</font></h1>
**<font style="color:#ED740C;">选择排序</font>**<font style="color:rgb(51, 51, 51);">是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</font>

<p><font style="color:rgb(29, 29, 32);">选择排序（selection sort）的工作原理非常简单：</font><strong><font style="color:rgb(29, 29, 32);">开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。</font></strong></p>
<h2 id="DEFsO"><font style="color:rgb(51, 51, 51);">1. 算法步骤</font></h2>
:::success
1. <font style="color:rgb(51, 51, 51);">首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</font>
2. <font style="color:rgb(51, 51, 51);">再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</font>
3. <font style="color:rgb(51, 51, 51);">重复第二步，直到所有元素均排序完毕。</font>

<p>:::</p>
<blockquote>
<p><strong><font style="color:#601BDE;">要点 </font></strong>💥</p>
<ul>
<li>每一轮选择，找出最大（最小）的元素，并把它交换到合适的位置</li>
</ul>
</blockquote>
<h2 id="Q3dBx"><font style="color:rgb(51, 51, 51);">2. 动图演示</font></h2>
![](https://cdn.nlark.com/yuque/0/2024/gif/40730112/1713705259895-77a2fdf4-1f31-4f1f-b847-b23be642aa1b.gif)

<h2 id="pbPpG"><font style="color:rgb(51, 51, 51);">3. 代码实现</font>🎆</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// 1. 选择轮数：nums.length - 1</span><br>    <span class="hljs-comment">// 2. 交换的索引right初始化为nums.length - 1，每次递减，将选择到的最大值与right位置交换</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; right &gt; <span class="hljs-number">0</span>; right--) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> right;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; right; i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[max]) &#123;<br>                max = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// max 值发生了变化才交换，否则不需要交换</span><br>        <span class="hljs-keyword">if</span> (max != right) &#123;<br>            <span class="hljs-comment">// 每一轮循环结束时，将选择到的最大的的值交换到最右侧</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[max];<br>            nums[max] = nums[right];<br>            nums[right] = t;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 每一轮循环结束时，将选择到的最小的的值交换到最左侧 同上</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; left &lt; arr.length - <span class="hljs-number">1</span>; left++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> left;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (minIndex != left) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[left];<br>            arr[left] = arr[minIndex];<br>            arr[minIndex] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="X0Uri"><font style="color:rgb(51, 51, 51);">4. 算法分析</font></h2>
+ **<font style="color:rgb(44, 62, 80);">稳定性</font>**<font style="color:rgb(44, 62, 80);">：不稳定</font>

<blockquote>
<p><font style="color:rgb(29, 29, 32);">如图下图所示，元素 </font><em>nums[ i ]__<font style="color:rgb(29, 29, 32);"> </font></em><font style="color:rgb(29, 29, 32);">有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变。</font></p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713705563461-9b8095a8-925a-45f1-8915-0d46e43c1b3c.png" srcset="/img/loading.gif" lazyload alt="选择排序非稳定示例"></p>
<ul>
<li><strong><font style="color:rgb(44, 62, 80);">时间复杂度</font></strong><font style="color:rgb(44, 62, 80);">：最佳：𝑂(𝑛</font><sup><font style="color:rgb(44, 62, 80);">2</font></sup><font style="color:rgb(44, 62, 80);">) ，最差：𝑂(𝑛</font><sup><font style="color:rgb(44, 62, 80);">2</font></sup><font style="color:rgb(44, 62, 80);">)， 平均：𝑂(𝑛</font><sup><font style="color:rgb(44, 62, 80);">2</font></sup><font style="color:rgb(44, 62, 80);">)</font></li>
<li><strong><font style="color:rgb(44, 62, 80);">空间复杂度</font></strong><font style="color:rgb(44, 62, 80);">：𝑂(1)</font></li>
<li><strong><font style="color:rgb(44, 62, 80);">排序方式</font></strong><font style="color:rgb(44, 62, 80);">：In-place</font></li>
</ul>
<hr>
<h1 id="dGEKL">三：插入排序 (Insertion Sort)</h1>
**<font style="color:#ED740C;">插入排序（insertion sort）</font>**<font style="color:rgb(29, 29, 32);">是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。</font>

<p><font style="color:rgb(51, 51, 51);">具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。</font></p>
<p><font style="color:rgb(29, 29, 32);">下图展示了数组插入元素的操作流程。设基准元素为 </font><code>base</code><font style="color:rgb(29, 29, 32);"> ，我们需要将从目标索引到 </font><code>base</code><font style="color:rgb(29, 29, 32);"> 之间的所有元素向右移动一位，然后将 </font><code>base</code><font style="color:rgb(29, 29, 32);"> 赋值给目标索引。</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713761185031-e3d192b0-1fae-4081-ba67-5b633906d84e.png" srcset="/img/loading.gif" lazyload alt="单次插入操作"></p>
<p><font style="color:rgb(29, 29, 32);">它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 </font><strong><font style="color:#ED740C;">in-place</font></strong><font style="color:rgb(29, 29, 32);"> 排序（即只需用到 O(1) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</font></p>
<p><font style="color:rgb(51, 51, 51);">插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</font></p>
<p><font style="color:rgb(51, 51, 51);">插入排序和冒泡排序一样，也有一种优化算法，叫做</font><strong><font style="color:rgb(51, 51, 51);">拆半插入</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<h2 id="JqIES">1. 算法步骤</h2>
<font style="color:rgb(29, 29, 32);">插入排序的整体流程如图所示。</font>

<pre><code class="hljs">1. &lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;初始状态下，数组的第 1 个元素已完成排序。&lt;/font&gt;
2. &lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;选取数组的第 2 个元素作为 &lt;/font&gt;`base`&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt; ，将其插入到正确位置后，&lt;/font&gt;**&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;数组的前 2 个元素已排序&lt;/font&gt;**&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;。&lt;/font&gt;
3. &lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;选取第 3 个元素作为 &lt;/font&gt;`base`&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt; ，将其插入到正确位置后，&lt;/font&gt;**&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;数组的前 3 个元素已排序&lt;/font&gt;**&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;。&lt;/font&gt;
4. &lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;以此类推，在最后一轮中，选取最后一个元素作为 &lt;/font&gt;`base`&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt; ，将其插入到正确位置后，&lt;/font&gt;**&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;所有元素均已排序&lt;/font&gt;**&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt;。&lt;/font&gt;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713761184921-3529b4dc-765c-42a0-8056-635fdbb82a3b.png" srcset="/img/loading.gif" lazyload alt="插入排序流程"></p>
<blockquote>
<p><strong><font style="color:#601BDE;">要点</font></strong>：💥</p>
<ul>
<li><em><font style="color:black;">将数组分为两部分[0 .. low-1] [low .. a.length-1]</font></em><ul>
<li><em><strong><font style="color:black;">左边[0 .. low-1]是已排序部分</font></strong></em></li>
<li><em><strong><font style="color:black;">右边[low .. a.length-1]是未排序部分</font></strong></em></li>
</ul>
</li>
<li><em><font style="color:black;">每次从未排序区域取出low位置的元素</font></em><font style="color:black;">, </font><em><font style="color:black;">插入到已排序区域</font></em></li>
</ul>
</blockquote>
<h2 id="pKTM7">2. 动图演示</h2>
![](https://cdn.nlark.com/yuque/0/2024/gif/40730112/1713761215240-99d4a573-cb16-41cd-aee8-5c27f58b23fa.gif)

<h2 id="hrgaM">3.代码实现🎆</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// 定义一个low指针，指向未排序区域的第一个数，默认从1开始，认为第一个数已经有序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">notSortedFirstIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; notSortedFirstIndex &lt; nums.length; notSortedFirstIndex++) &#123;<br>        <span class="hljs-comment">// 定义一个指针指向已排序区域的最后一个指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sortedLastIndex</span> <span class="hljs-operator">=</span> notSortedFirstIndex - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 记录未排序区域的第一个值，用于后序插入</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> nums[notSortedFirstIndex];<br>        <span class="hljs-comment">// 如果以排序区域的最后一个值大于未排序区域的第一个值，则将已排序区域的最后一个值向后移动</span><br>        <span class="hljs-keyword">while</span> (sortedLastIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[sortedLastIndex] &gt; current) &#123;<br>            nums[sortedLastIndex + <span class="hljs-number">1</span>] = nums[sortedLastIndex];<br>            sortedLastIndex--;<br>        &#125;<br>        <span class="hljs-comment">// 循环结束，说明已经找到插入位置</span><br>        <span class="hljs-keyword">if</span> (sortedLastIndex != notSortedFirstIndex - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 上面的i是经过--以后不满足while条件退出循环，因此在插入时需要在i+1位置插入</span><br>            nums[sortedLastIndex + <span class="hljs-number">1</span>] = current;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 插入排序 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// i=&gt;未排序区域的第一个指针</span><br>    <span class="hljs-comment">// j=&gt;以排序区域的最后一个指针</span><br>    <span class="hljs-comment">// base=&gt;暂存未排序区域中选择的基准元素</span><br>    <span class="hljs-comment">// 外循环：已排序区间为 [0, i-1]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> nums[i], j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[j] &gt; base) &#123;<br>            nums[j + <span class="hljs-number">1</span>] = nums[j]; <span class="hljs-comment">// 将 nums[j] 向右移动一位</span><br>            j--;<br>        &#125;<br>        nums[j + <span class="hljs-number">1</span>] = base;        <span class="hljs-comment">// 将 base 赋值到正确位置</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="SBZEA">4. 算法分析</h2>
+ **<font style="color:rgb(44, 62, 80);">稳定性</font>**<font style="color:rgb(44, 62, 80);">：稳定</font>

<p>:::color1<br><font style="color:rgb(29, 29, 32);">在插入操作过程中，我们会</font><strong><font style="color:rgb(29, 29, 32);">将元素插入到相等元素的右侧</font></strong><font style="color:rgb(29, 29, 32);">，不会改变它们的顺序。</font></p>
<p>:::</p>
<ul>
<li><strong><font style="color:rgb(44, 62, 80);">时间复杂度</font></strong><font style="color:rgb(44, 62, 80);">：最佳：</font><code>_**&lt;font style=&quot;color:#ED740C;&quot;&gt;𝑂(𝑛)&lt;/font&gt;**_</code><em><strong><font style="color:#ED740C;"> </font></strong></em><font style="color:rgb(44, 62, 80);">，最差：</font><code>_**&lt;font style=&quot;color:#ED740C;&quot;&gt;𝑂(𝑛&lt;/font&gt;**_&lt;sup&gt;_**&lt;font style=&quot;color:#ED740C;&quot;&gt;2&lt;/font&gt;**_&lt;/sup&gt;_**&lt;font style=&quot;color:#ED740C;&quot;&gt;)&lt;/font&gt;**_</code><font style="color:rgb(44, 62, 80);">， 平均：</font><code>_**&lt;font style=&quot;color:#ED740C;&quot;&gt;𝑂(𝑛&lt;/font&gt;**_&lt;sup&gt;_**&lt;font style=&quot;color:#ED740C;&quot;&gt;2&lt;/font&gt;**_&lt;/sup&gt;_**&lt;font style=&quot;color:#ED740C;&quot;&gt;)&lt;/font&gt;**_</code></li>
<li><strong><font style="color:rgb(44, 62, 80);">空间复杂度</font></strong><font style="color:rgb(44, 62, 80);">：</font><code>_**&lt;font style=&quot;color:#ED740C;&quot;&gt;O(1)&lt;/font&gt;**_</code></li>
<li><strong><font style="color:rgb(44, 62, 80);">排序方式</font></strong><font style="color:rgb(44, 62, 80);">：</font><strong><font style="color:#DF2A3F;">In-place</font></strong></li>
</ul>
<h2 id="zr4Vy"><font style="color:rgb(29, 29, 32);">5. 插入排序的优势</font></h2>
:::color1
<font style="color:rgb(29, 29, 32);">插入排序的时间复杂度为 </font>`_**<font style="color:#ED740C;">𝑂(𝑛</font>**_<sup>_**<font style="color:#ED740C;">2</font>**_</sup>_**<font style="color:#ED740C;">)</font>**_<font style="color:rgb(29, 29, 32);"> </font>`<font style="color:rgb(29, 29, 32);">，而我们即将学习的快速排序的时间复杂度为 </font>`_**<font style="color:#ED740C;">𝑂(𝑛log⁡𝑛)</font>**_<font style="color:#ED740C;"> </font>`<font style="color:rgb(29, 29, 32);">。尽管插入排序的时间复杂度更高，但</font>**<font style="color:#117CEE;">在数据量较小的情况下，插入排序通常更快。</font>**

<p><font style="color:rgb(29, 29, 32);">这个结论与线性查找和二分查找的适用情况的结论类似。快速排序这类 </font><code>_**&lt;font style=&quot;color:#ED740C;&quot;&gt;𝑂(𝑛log⁡𝑛)&lt;/font&gt;**_&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt; &lt;/font&gt;</code><font style="color:rgb(29, 29, 32);">的算法属于基于</font><strong><font style="color:rgb(29, 29, 32);">分治策略</font></strong><font style="color:rgb(29, 29, 32);">的排序算法，往往包含更多单元计算操作。而在数据量较小时，</font><code>_**&lt;font style=&quot;color:#ED740C;&quot;&gt;𝑛&lt;/font&gt;**_&lt;sup&gt;_**&lt;font style=&quot;color:#ED740C;&quot;&gt;2&lt;/font&gt;**_&lt;/sup&gt;&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt; &lt;/font&gt;</code><font style="color:rgb(29, 29, 32);">和 </font><code>_**&lt;font style=&quot;color:#ED740C;&quot;&gt;𝑛log⁡𝑛&lt;/font&gt;**_&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt; &lt;/font&gt;</code><font style="color:rgb(29, 29, 32);">的数值比较接近，复杂度不占主导地位，每轮中的单元操作数量起到决定性作用。</font></p>
<p><strong><font style="color:rgb(29, 29, 32);">实际上，许多编程语言（例如 Java）的内置排序函数采用了插入排序，大致思路为：</font>****<font style="color:rgb(29, 29, 32);background-color:#FBDE28;">对于长数组，采用基于分治策略的排序算法，例如快速排序；对于短数组，直接使用插入排序。</font></strong></p>
<p><font style="color:rgb(29, 29, 32);">虽然冒泡排序、选择排序和插入排序的时间复杂度都为 </font><code>_**&lt;font style=&quot;color:#ED740C;&quot;&gt;𝑂(𝑛&lt;/font&gt;**_&lt;sup&gt;_**&lt;font style=&quot;color:#ED740C;&quot;&gt;2&lt;/font&gt;**_&lt;/sup&gt;_**&lt;font style=&quot;color:#ED740C;&quot;&gt;)&lt;/font&gt;**_&lt;font style=&quot;color:rgb(29, 29, 32);&quot;&gt; &lt;/font&gt;</code><font style="color:rgb(29, 29, 32);">，但在实际情况中，插入排序的使用频率显著高于冒泡排序和选择排序，主要有以下原因。</font></p>
<ul>
<li><font style="color:rgb(29, 29, 32);">冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，</font><strong><font style="color:rgb(29, 29, 32);">冒泡排序的计算开销通常比插入排序更高。</font></strong></li>
<li><font style="color:rgb(29, 29, 32);">选择排序在任何情况下的时间复杂度都为</font><em><strong><font style="color:#ED740C;"> </font></strong></em><code>_**&lt;font style=&quot;color:#ED740C;&quot;&gt;𝑂(𝑛&lt;/font&gt;**_&lt;sup&gt;_**&lt;font style=&quot;color:#ED740C;&quot;&gt;2&lt;/font&gt;**_&lt;/sup&gt;_**&lt;font style=&quot;color:#ED740C;&quot;&gt;) &lt;/font&gt;**_</code><font style="color:rgb(29, 29, 32);">。</font><strong><font style="color:rgb(29, 29, 32);">如果给定一组部分有序的数据，插入排序通常比选择排序效率更高。</font></strong></li>
<li><strong><font style="color:rgb(29, 29, 32);">选择排序不稳定，无法应用于多级排序。</font></strong></li>
</ul>
<p>:::</p>
<hr>
<h1 id="AOrgf">四：希尔排序 (Shell Sort)</h1>
<font style="color:rgb(51, 51, 51);"> 	</font>**<font style="color:#ED740C;">希尔排序</font>**<font style="color:rgb(51, 51, 51);">是希尔 (Donald Shell) 于 1959 年提出的一种排序算法。希尔排序的实质是分组插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为</font>**<font style="color:#ED740C;">递减增量排序算法</font>**<font style="color:rgb(51, 51, 51);">，同时</font>**<font style="color:#117CEE;">该算法是冲破 O(n</font>**<sup>**<font style="color:#117CEE;">2</font>**</sup>**<font style="color:#117CEE;">) 的第一批算法之一</font>**<font style="color:rgb(51, 51, 51);">，但希尔排序是</font>**<font style="color:#DF2A3F;">非稳定</font>**<font style="color:rgb(51, 51, 51);">排序算法。 </font>

<p><font style="color:rgb(51, 51, 51);">希尔排序是基于插入排序的以下两点性质而提出改进方法的：</font></p>
<ul>
<li><font style="color:rgb(51, 51, 51);">插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</font></li>
<li><font style="color:rgb(51, 51, 51);">但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</font></li>
</ul>
<p><font style="color:rgb(51, 51, 51);">希尔排序的基本思想是：</font><strong><font style="color:rgb(51, 51, 51);"> 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长或增量)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap&#x3D;1时，整个数列就是有序的。</font></strong></p>
<h2 id="LUJos">1.算法步骤</h2>
<font style="color:rgb(51, 51, 51);">我们来看下希尔排序的基本步骤，在此我们选择增量 </font>`<font style="color:#ED740C;">gap=length/2</font>`<font style="color:rgb(51, 51, 51);">，缩小增量继续以</font>`<font style="color:#ED740C;">gap=gap/2</font>`<font style="color:rgb(51, 51, 51);">的方式，这种增量选择我们可以用一个序列来表示</font>**<font style="color:rgb(51, 51, 51);"> {</font>**$ \frac{n}{2},\frac{(n/2)}{2},...,1 $**<font style="color:rgb(51, 51, 51);">} </font>**<font style="color:rgb(51, 51, 51);">，称为</font>**<font style="color:rgb(51, 51, 51);">增量序列</font>**<font style="color:rgb(51, 51, 51);">。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为</font>**<font style="color:rgb(51, 51, 51);">希尔增量</font>**<font style="color:rgb(51, 51, 51);">，但其实这个增量序列不是最优的。</font>**<font style="color:#601BDE;">此处我们做示例使用希尔增量。</font>**

<p><font style="color:rgb(51, 51, 51);">先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</font></p>
<ul>
<li><font style="color:rgb(44, 62, 80);">选择一个增量序列 </font><strong><font style="color:rgb(44, 62, 80);">{ 𝑡</font></strong><sub><strong><font style="color:rgb(44, 62, 80);">1</font></strong></sub><strong><font style="color:rgb(44, 62, 80);"> , 𝑡</font></strong><sub><strong><font style="color:rgb(44, 62, 80);">2</font></strong></sub><strong><font style="color:rgb(44, 62, 80);"> , … , 𝑡</font></strong><sub><strong><font style="color:rgb(44, 62, 80);">𝑘</font></strong></sub><strong><font style="color:rgb(44, 62, 80);"> }</font></strong><font style="color:rgb(44, 62, 80);">，其中</font><strong><font style="color:rgb(44, 62, 80);"> 𝑡</font></strong><sub><strong><font style="color:rgb(44, 62, 80);">𝑖</font></strong></sub><strong><font style="color:rgb(44, 62, 80);"> &gt; 𝑡</font></strong><sub><strong><font style="color:rgb(44, 62, 80);">𝑗</font></strong></sub><strong><font style="color:rgb(44, 62, 80);"> , 𝑖 &lt; 𝑗 , 𝑡</font></strong><sub><strong><font style="color:rgb(44, 62, 80);">𝑘</font></strong></sub><strong><font style="color:rgb(44, 62, 80);"> &#x3D; 1</font></strong><font style="color:rgb(44, 62, 80);">；</font></li>
<li><font style="color:rgb(51, 51, 51);">按增量序列个数 k，对序列进行 k 趟排序；</font></li>
<li><font style="color:rgb(51, 51, 51);">每趟排序，根据对应的增量 t，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</font></li>
</ul>
<blockquote>
<p><strong><font style="color:#601BDE;">要点:</font></strong>💥</p>
<ul>
<li><font style="color:black;">简单的说，就是</font><strong><font style="color:black;">分组实现插入</font></strong><font style="color:black;">，每组元素间隙称为 gap</font></li>
<li><font style="color:black;">每轮排序后 gap 逐渐变小，直至 gap 为 1 完成排序 </font></li>
<li><font style="color:black;">对插入排序的优化，让元素更快速地交换到最终位置</font></li>
</ul>
<p><font style="color:rgb(0, 0, 0);">下图演示了 gap &#x3D; 4，gap &#x3D; 2，gap &#x3D; 1 的三轮排序前后比较</font></p>
<p><font style="color:rgb(0, 0, 0);"></font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713764474297-d9a5b25b-f3cf-41fa-8733-49c35520ead4.png" srcset="/img/loading.gif" lazyload alt="希尔排序"></p>
</blockquote>
<h2 id="TZbek">2.图解算法</h2>
![](https://cdn.nlark.com/yuque/0/2024/png/40730112/1713763367423-9749273e-95b9-46c0-b633-340ec258e581.png)

<h2 id="aQybi">3.模拟算法</h2>
下面以数列**{80,30,60,40,20,10,50,70}**为例，演示它的希尔排序过程。

<p>第1趟: <strong><font style="color:#117CEE;">(gap&#x3D;4)</font></strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/40730112/1713860353697-d29b7801-fde6-4e0e-9e3b-c19eee5efdca.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>当gap&#x3D;4时,意味着将数列分为4个组: <code>&#123;80,20&#125;,&#123;30,10&#125;,&#123;60,50&#125;,&#123;40,70&#125;</code>。 对应数列: <code>&#123;80,30,60,40,20,10,50,70&#125;</code> 对这4个组分别进行排序，排序结果: <code>&#123;20,80&#125;,&#123;10,30&#125;,&#123;50,60&#125;,&#123;40,70&#125;</code>。 对应数列: <code>&#123;20,10,50,40,80,30,60,70&#125;</code></p>
<p>第2趟: <strong><font style="color:#117CEE;">(gap&#x3D;2)</font></strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/40730112/1713860389510-21c544cc-0598-47c4-b132-100af8745c59.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>当gap&#x3D;2时,意味着将数列分为2个组: <code>&#123;20,50,80,60&#125;</code>, <code>&#123;10,40,30,70&#125;</code>。 对应数列: <code>&#123;20,10,50,40,80,30,60,70&#125;</code> **注意: **<code>&#123;20,50,80,60&#125;</code>实际上有两个有序的数列<code>&#123;20,80&#125;</code>和<code>&#123;50,60&#125;</code>组成。 <code>&#123;10,40,30,70&#125;</code>实际上有两个有序的数列<code>&#123;10,30&#125;</code>和<code>&#123;40,70&#125;</code>组成。 对这2个组分别进行排序，排序结果: <code>&#123;20,50,60,80&#125;, &#123;10,30,40,70&#125;</code>。 对应数列: <code>&#123;20,10,50,30,60,40,80,70&#125;</code></p>
<p>第3趟: <strong><font style="color:#117CEE;">(gap&#x3D;1)</font></strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/40730112/1713860578845-542d4516-0ae4-4173-8bbb-4d3553fa4b7a.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>当gap&#x3D;1时,意味着将数列分为1个组: <code>&#123;20,10,50,30,60,40,80,70&#125;</code> 注意: <code>&#123;20,10,50,30,60,40,80,70&#125;</code>实际上有两个有序的数列<code>&#123;20,50,60,80&#125;</code>和<code>&#123;10,30,40,70&#125;</code>组成。</p>
<details class="lake-collapse"><summary id="u8881dcc7"><strong><span class="ne-text" style="color: #601BDE">Tips</span></strong></summary><p id="udb032ffe" class="ne-p"><span class="ne-text">通过上述的代码模拟过程，我们可以看到，希尔排序每轮将以 gap 为间隙的数据分为一组，对分好的组内先进行一轮插入排序，然后使得 gap 缩小，意味着每一组中的数据个数变多，但是，这一组数据是在前一轮排序后重新分组的，也就是说</span><strong><span class="ne-text" style="background-color: #FBDE28">第二轮排序是在第一轮排序的基础之上，那么组内元素就有第一轮排序的前提，也就是局部有序的</span></strong><span class="ne-text">，这</span><strong><span class="ne-text">充分了利用了</span></strong><strong><span class="ne-text" style="background-color: #FBDE28">插入排序对于局部有序数据排序的高效性</span></strong><strong><span class="ne-text">。</span></strong><span class="ne-text">后序轮次以此类推，直到 gap 缩小为 1，也就是只分一组，对所有元素进行最后一轮排序。</span></p></details>
<h2 id="XCnkr">4.代码实现🎆</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// 定义分组间隙 gap ，初始为数组长度的一半，每次循环右位移一位（除以二）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> nums.length &gt;&gt; <span class="hljs-number">1</span>; gap &gt;= <span class="hljs-number">1</span>; gap = gap &gt;&gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// notSortedFirstIndex 未排序数组的第一个指针</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">notSortedFirstIndex</span> <span class="hljs-operator">=</span> gap; notSortedFirstIndex &lt; nums.length; notSortedFirstIndex++) &#123;<br>            <span class="hljs-comment">// 未排序区域的第一个元素值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> nums[notSortedFirstIndex];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sortedLastIndex</span> <span class="hljs-operator">=</span> notSortedFirstIndex - gap; <span class="hljs-comment">// 排序数组的最后一个数据指针</span><br>            <span class="hljs-comment">// 插入排序的过程</span><br>            <span class="hljs-keyword">while</span> (sortedLastIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[sortedLastIndex] &gt; current) &#123;<br>                nums[sortedLastIndex + gap] = nums[sortedLastIndex];<br>                sortedLastIndex -= gap;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (sortedLastIndex != notSortedFirstIndex - gap) &#123;<br>                nums[sortedLastIndex + gap] = current;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> arr.length &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (gap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">// 未排序区域的第一个元素值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-comment">// 已排序区域的最后一个元素指针</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">preIndex</span> <span class="hljs-operator">=</span> i - gap;<br>            <span class="hljs-comment">// Insertion sort</span><br>            <span class="hljs-keyword">while</span> (preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>                <span class="hljs-comment">// 后移</span><br>                arr[preIndex + gap] = arr[preIndex];<br>                preIndex -= gap;<br>            &#125;<br>            arr[preIndex + gap] = current;<br><br>        &#125;<br>        <span class="hljs-comment">// 取下一个希尔增量</span><br>        gap = gap &gt;&gt; <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="eHPDL">5.算法分析</h2>
+ **<font style="color:rgb(44, 62, 80);">稳定性</font>**<font style="color:rgb(44, 62, 80);">：</font>**<font style="color:#DF2A3F;">不稳定</font>**
+ **<font style="color:rgb(44, 62, 80);">时间复杂度</font>**<font style="color:rgb(44, 62, 80);">：最佳：</font>`_**<font style="color:#ED740C;">𝑂(𝑛𝑙𝑜𝑔𝑛)</font>**_`<font style="color:rgb(44, 62, 80);">， 最差：</font>`_**<font style="color:#ED740C;">𝑂(𝑛</font>**_<sup>_**<font style="color:#ED740C;">2</font>**_</sup>_**<font style="color:#ED740C;">)</font>**_`<font style="color:rgb(44, 62, 80);"> 平均：</font>`_**<font style="color:#ED740C;">𝑂(𝑛𝑙𝑜𝑔𝑛)</font>**_`
+ **<font style="color:rgb(44, 62, 80);">空间复杂度</font>**<font style="color:rgb(44, 62, 80);">：</font>`_**<font style="color:#ED740C;">O(1)</font>**_`



<hr>
<h1 id="zxWNy">五：归并排序(merge sort)</h1>
**<font style="color:#ED740C;">归并排序（merge sort）</font>**<font style="color:rgb(29, 29, 32);">是一种基于</font>**<font style="color:#601BDE;">分治策略</font>**<font style="color:rgb(29, 29, 32);">的排序算法，包含下图所示的</font>**<font style="color:rgb(29, 29, 32);">“划分”</font>**<font style="color:rgb(29, 29, 32);">和</font>**<font style="color:rgb(29, 29, 32);">“合并”</font>**<font style="color:rgb(29, 29, 32);">阶段。</font>

<ol>
<li><strong><font style="color:rgb(29, 29, 32);">划分阶段</font></strong><font style="color:rgb(29, 29, 32);">：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。</font></li>
<li><strong><font style="color:rgb(29, 29, 32);">合并阶段</font></strong><font style="color:rgb(29, 29, 32);">：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。</font></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713861162759-548ab726-b7b7-4bc5-99fe-e8779f698bfe.png" srcset="/img/loading.gif" lazyload></p>
<p><font style="color:rgb(44, 62, 80);">归并排序是一种</font><strong><font style="color:#601BDE;">稳定</font></strong><font style="color:rgb(44, 62, 80);">的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2 - 路归并。</font></p>
<p><font style="color:rgb(44, 62, 80);">和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 </font><em><strong><font style="color:#ED740C;">𝑂(𝑛𝑙𝑜𝑔𝑛)</font></strong></em><font style="color:rgb(44, 62, 80);"> 的时间复杂度。</font><strong><font style="color:rgb(44, 62, 80);">代价是需要额外的内存空间。（空间换时间思想）</font></strong></p>
<blockquote>
<p><font style="color:rgb(44, 62, 80);">根据具体的实现，归并排序包括</font><strong><font style="color:rgb(44, 62, 80);">“从上往下”</font></strong><font style="color:rgb(44, 62, 80);">和</font><strong><font style="color:rgb(44, 62, 80);">“从下往上”</font></strong><font style="color:rgb(44, 62, 80);">2种方式。</font></p>
<p><strong>所谓 自下至上 就是先排序2个元素，再归并为4个元素排序，再归并为8个元素排序</strong></p>
<p><strong>而 自上至下 就是先排序 数组长度一半的元素，再拆分为四分之一，八分之一</strong></p>
</blockquote>
<h2 id="fRlvI">1.算法步骤</h2>
<h3 id="gOVDW">从下往上的归并排序</h3>
将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；得到若干个长度为2的有序数列，再将这些数列两两合并；得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。(参考下面的图片)

<h3 id="LXnp9">从上往下的归并排序</h3>
它与"从下往上"在排序上是反方向的。它基本包括3步:

<ul>
<li><strong>分 -</strong> 将当前区间一分为二，即求分裂点 mid &#x3D; (low + high)&#x2F;2;</li>
<li><strong>治 -</strong> 递归地对两个子区间<code>a[low...mid]</code> 和 <code>a[mid+1...high]</code>进行归并排序。递归的终结条件是子区间长度为1。<strong>（后序可以结合插入排序进行优化）</strong></li>
<li><strong>合 -</strong> 将已排序的两个子区间<code>a[low...mid]</code>和 <code>a[mid+1...high]</code>归并为一个有序的区间<code>a[low...high]</code>。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/40730112/1713861735521-4b2185f8-c0d8-484a-93a5-78a32d8b6013.jpeg" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p><strong><font style="color:#601BDE;">要点:</font></strong>💥</p>
<ul>
<li><font style="color:black;">分 - 每次从中间切一刀，处理的数据少一半</font></li>
<li><font style="color:black;">治 - 当数据仅剩一个时可以认为有序</font></li>
<li><font style="color:black;">合 - 两个有序的结果，可以进行合并排序</font></li>
</ul>
</blockquote>
<h2 id="SfccB">2.动图演示</h2>
> 以下动图演示的是从下往上的归并排序
>

<p><img src="https://cdn.nlark.com/yuque/0/2024/gif/40730112/1713861786160-9cb8e332-91f7-4c1b-a094-17b247c7374c.gif" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/gif/40730112/1713862301842-71cfd622-a543-46d3-95b0-5f5cd9da37e0.gif" srcset="/img/loading.gif" lazyload></p>
<h2 id="uvMMO">3.模拟算法</h2>
<h3 id="CvNJQ">从上往下的归并排序</h3>
从上往下的归并排序采用了**递归**的方式实现。它的原理非常简单，如下图:

<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/40730112/1713861861363-ec10d9f2-7b6c-4228-812e-3e6298f56cb7.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>通过”从上往下的归并排序”来对数组{80,30,60,40,20,10,50,70}进行排序时:</p>
<ul>
<li><strong><font style="color:#81BBF8;">将数组</font></strong><code>**&lt;font style=&quot;color:#81BBF8;&quot;&gt;&#123;80,30,60,40,20,10,50,70&#125;&lt;/font&gt;**</code><strong><font style="color:#81BBF8;">看作由两个有序的子数组</font></strong><code>**&lt;font style=&quot;color:#81BBF8;&quot;&gt;&#123;80,30,60,40&#125;&lt;/font&gt;**</code><strong><font style="color:#81BBF8;">和</font></strong><code>**&lt;font style=&quot;color:#81BBF8;&quot;&gt;&#123;20,10,50,70&#125;&lt;/font&gt;**</code><strong><font style="color:#81BBF8;">组成。对两个有序子树组进行排序即可。</font></strong><ul>
<li><strong><font style="color:#8CCF17;">将子数组</font></strong><code>**&lt;font style=&quot;color:#8CCF17;&quot;&gt;&#123;80,30,60,40&#125;&lt;/font&gt;**</code><strong><font style="color:#8CCF17;">看作由两个有序的子数组</font></strong><code>**&lt;font style=&quot;color:#8CCF17;&quot;&gt;&#123;80,30&#125;&lt;/font&gt;**</code><strong><font style="color:#8CCF17;">和</font></strong><code>**&lt;font style=&quot;color:#8CCF17;&quot;&gt;&#123;60,40&#125;&lt;/font&gt;**</code><strong><font style="color:#8CCF17;">组成。 </font></strong></li>
<li><strong><font style="color:#8CCF17;">将子数组</font></strong><code>**&lt;font style=&quot;color:#8CCF17;&quot;&gt;&#123;20,10,50,70&#125;&lt;/font&gt;**</code><strong><font style="color:#8CCF17;">看作由两个有序的子数组</font></strong><code>**&lt;font style=&quot;color:#8CCF17;&quot;&gt;&#123;20,10&#125;&lt;/font&gt;**</code><strong><font style="color:#8CCF17;">和</font></strong><code>**&lt;font style=&quot;color:#8CCF17;&quot;&gt;&#123;50,70&#125;&lt;/font&gt;**</code><strong><font style="color:#8CCF17;">组成。</font></strong></li>
</ul>
</li>
<li><strong><font style="color:#F38F39;">将子数组</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;80,30&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">看作由两个有序的子数组</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;80&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">和</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;30&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">组成。 </font></strong></li>
<li><strong><font style="color:#F38F39;">将子数组</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;60,40&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">看作由两个有序的子数组</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;60&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">和</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;40&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">组成。</font></strong></li>
<li><strong><font style="color:#F38F39;">将子数组</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;20,10&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">看作由两个有序的子数组</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;20&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">和</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;10&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">组成。</font></strong></li>
<li><strong><font style="color:#F38F39;">将子数组</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;50,70&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">看作由两个有序的子数组</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;50&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">和</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;70&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">组成。</font></strong></li>
</ul>
<h3 id="jWK4c">从下往上的归并排序</h3>
从下往上的归并排序的思想正好与"从下往上的归并排序"相反。如下图:

<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/40730112/1713862059883-ccac732a-7606-468f-98a5-3d025ce140be.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>通过”从下往上的归并排序”来对数组<code>&#123;80,30,60,40,20,10,50,70&#125;</code>进行排序时:</p>
<ul>
<li><strong><font style="color:#81BBF8;">将数组</font></strong><code>**&lt;font style=&quot;color:#81BBF8;&quot;&gt;&#123;80,30,60,40,20,10,50,70&#125;&lt;/font&gt;**</code><strong><font style="color:#81BBF8;">看作由8个有序的子数组</font></strong><code>**&lt;font style=&quot;color:#81BBF8;&quot;&gt;&#123;80&#125;,&#123;30&#125;,&#123;60&#125;,&#123;40&#125;,&#123;20&#125;,&#123;10&#125;,&#123;50&#125;&lt;/font&gt;**</code><strong><font style="color:#81BBF8;">和</font></strong><code>**&lt;font style=&quot;color:#81BBF8;&quot;&gt;&#123;70&#125;&lt;/font&gt;**</code><strong><font style="color:#81BBF8;">组成。</font></strong></li>
<li><strong><font style="color:#8CCF17;">将这8个有序的子数列两两合并。得到4个有序的子树列</font></strong><code>**&lt;font style=&quot;color:#8CCF17;&quot;&gt;&#123;30,80&#125;&lt;/font&gt;**</code><strong><font style="color:#8CCF17;">,</font></strong><code>**&lt;font style=&quot;color:#8CCF17;&quot;&gt;&#123;40,60&#125;&lt;/font&gt;**</code><strong><font style="color:#8CCF17;">,</font></strong><code>**&lt;font style=&quot;color:#8CCF17;&quot;&gt;&#123;10,20&#125;&lt;/font&gt;**</code><strong><font style="color:#8CCF17;">和</font></strong><code>**&lt;font style=&quot;color:#8CCF17;&quot;&gt;&#123;50,70&#125;&lt;/font&gt;**</code><strong><font style="color:#8CCF17;">。</font></strong></li>
<li><strong><font style="color:#F38F39;">将这4个有序的子数列两两合并。得到2个有序的子树列</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;30,40,60,80&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">和</font></strong><code>**&lt;font style=&quot;color:#F38F39;&quot;&gt;&#123;10,20,50,70&#125;&lt;/font&gt;**</code><strong><font style="color:#F38F39;">。</font></strong></li>
<li><strong><font style="color:#601BDE;">将这2个有序的子数列两两合并。得到1个有序的子树列</font></strong><code>**&lt;font style=&quot;color:#601BDE;&quot;&gt;&#123;10,20,30,40,50,60,70,80&#125;&lt;/font&gt;**</code><strong><font style="color:#601BDE;">。</font></strong></li>
</ul>
<h2 id="gaIc9">4.代码实现🎆</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 参数一：待排序数组</span><br><span class="hljs-comment">         * 参数二：待排序数组的区域左标</span><br><span class="hljs-comment">         * 参数二：待排序数组的区域右标</span><br><span class="hljs-comment">         * 参数三：临时数组，用来合并数组时使用</span><br><span class="hljs-comment">         */</span><br>    split(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>, arr);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">split</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 治</span><br>    <span class="hljs-keyword">if</span> (left == right) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 分</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    split(nums, left, mid, arr);<br>    split(nums, mid + <span class="hljs-number">1</span>, right, arr);<br>    <span class="hljs-comment">// 合</span><br>    merge(nums, left, mid, mid + <span class="hljs-number">1</span>, right, arr);<br>    System.arraycopy(arr, left, nums, left, right - left + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 合并有序数组</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums 原始数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i  iEnd 第一个有序范围</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> j  jEnd 第二个有序范围</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr 临时数组</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> iEnd, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> jEnd, <span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 定义一个指针k用于构建临时数组</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i;<br>    <span class="hljs-keyword">while</span> (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) &#123;<br>        <span class="hljs-comment">// 每次将 i ~ iEnd 或者 j ~ jEnd 中更小的数加入到临时数组，并将指针后移</span><br>        <span class="hljs-keyword">if</span> (nums[i] &lt; nums[j]) &#123;<br>            arr[k] = nums[i];<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            arr[k] = nums[j];<br>            j++;<br>        &#125;<br>        k++;<br>    &#125;<br>    <span class="hljs-comment">// 当 i ~ iEnd 或 j ~ jEnd 其中一个区域的数据全部被加入到临时数组，则把另一个区域的数据拷贝到临时数组中</span><br>    <span class="hljs-keyword">if</span> (i &gt; iEnd) &#123;<br>        System.arraycopy(nums, j, arr, k, jEnd - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j &gt; jEnd) &#123;<br>        System.arraycopy(nums, i, arr, k, iEnd - i + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>    <span class="hljs-comment">// width 代表有序区间的宽度，取值依次为 1,2,4 ...</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; width &lt; len; width *= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// [left,right] 分别代表合并区间的左右边界</span><br>        <span class="hljs-comment">// 每次合并两个有序区间，因此左边界每次循环 ＋ 2 * width</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; left &lt; len; left += <span class="hljs-number">2</span> * width) &#123;<br>            <span class="hljs-comment">//右边界为下次左边界 - 1</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Math.min(len - <span class="hljs-number">1</span>, left + <span class="hljs-number">2</span> * width - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//中间值mid为左边界 + 一个宽度width - 1</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> Math.min(len - <span class="hljs-number">1</span>, left + width - <span class="hljs-number">1</span>);<br>            merge(nums, left, mid, mid + <span class="hljs-number">1</span>, right, arr);<br>        &#125;<br>        System.arraycopy(arr, <span class="hljs-number">0</span>, nums, <span class="hljs-number">0</span>, len);<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 合并有序数组</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums 原始数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i  iEnd 第一个有序范围</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> j  jEnd 第二个有序范围</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr 临时数组</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> iEnd, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> jEnd, <span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 定义一个k操作临时数组</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i;<br>    <span class="hljs-comment">//如果i和j都在有效范围内</span><br>    <span class="hljs-keyword">while</span> (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) &#123;<br>        <span class="hljs-comment">//比较i和j处索引的数组的值，并把较小的值加入到临时数组a2中</span><br>        <span class="hljs-keyword">if</span> (nums[i] &lt; nums[j]) &#123;<br>            arr[k] = nums[i];<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            arr[k] = nums[j];<br>            j++;<br>        &#125;<br>        <span class="hljs-comment">//更新操作临时数组的指针</span><br>        k++;<br>    &#125;<br>    <span class="hljs-comment">// 当i &gt; iEnd说明第一个有序范围内的元素已经全部迭代，将第二范围内没有被迭代的元素拷贝到arr数组即可</span><br>    <span class="hljs-keyword">if</span> (i &gt; iEnd) &#123;<br>        System.arraycopy(nums, j, arr, k, jEnd - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 当j &gt; jEnd说明第二个有序范围内的元素已经全部迭代，将第一范围内没有被迭代的元素拷贝到arr数组即可</span><br>    <span class="hljs-keyword">if</span> (j &gt; jEnd) &#123;<br>        System.arraycopy(nums, i, arr, k, iEnd - i + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>代码优化：</strong></p>
<p>通过上面学习的两类排序算法**<font style="color:#ED740C;">插入排序</font><strong>和</strong><font style="color:#ED740C;">归并排序</font>**，我们发现，如果是小数据量且有序度高时，插入排序的效果要高于归并排序，而如果数据量很大时，更适合使用归并排序，因此，我们可以结合两类排序的优缺点，于是有了下述 <strong><font style="color:#ED740C;">归并排序+插入排序</font></strong>：</p>
<p>:::color1<br><strong>当分区范围 <strong><strong><font style="color:#601BDE;">&lt;&#x3D; 32</font></strong></strong> 后，采用插入排序实现有序！</strong></p>
<p><strong>传统的归并排序必须等到 left &#x3D;&#x3D; right 即分区范围内只有一个元素时才视为有序，通过整合插入排序，可以对小范围内</strong>**<font style="color:#601BDE;">（&lt;&#x3D;32）</font>**<strong>的元素直接采用插入排序后即可视为有序，不用一直递归调用直到分区内只有一个元素，提高效率和性能。</strong></p>
<p>:::</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeInsertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>    <span class="hljs-type">int</span>[] a2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length];<br>    split(a, <span class="hljs-number">0</span>, a.length - <span class="hljs-number">1</span>, a2);<br>&#125;<br><br><span class="hljs-comment">//归并排序分区方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">split</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span>[] a2)</span> &#123;<br>    <span class="hljs-comment">// 治：当分区范围 &lt;= 32后，采用插入排序实现有序</span><br>    <span class="hljs-comment">// 传统的归并排序必须等到 left == right 即分区范围内只有一个元素时才视为有序</span><br>    <span class="hljs-comment">// 通过整合插入排序，可以对小范围内（&lt;=32）的元素直接采用插入排序后即可视为有序</span><br>    <span class="hljs-comment">// 不用一直递归调用到分区内只有一个元素，提高效率和性能</span><br>    <span class="hljs-keyword">if</span> (right - left &lt;= <span class="hljs-number">32</span>) &#123;<br>        <span class="hljs-comment">//插入排序</span><br>        insertionSort(a, left, right);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 分</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (right - left) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    split(a, left, mid, a2);<br>    split(a, mid + <span class="hljs-number">1</span>, right, a2);<br>    <span class="hljs-comment">// 合</span><br>    merge(a, left, mid, mid + <span class="hljs-number">1</span>, right, a2);<br>    System.arraycopy(a2, left, a, left, right - left + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入排序</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>; low &lt;= right; low++) &#123;<br>        <span class="hljs-comment">//定义一个变量t记录未排序区域的第一个值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> a[low];<br>        <span class="hljs-comment">//定义一个指针 i 为已排序区域的最后一个值的指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= left &amp;&amp; a[i] &gt; t) &#123;<br>            a[i + <span class="hljs-number">1</span>] = a[i];<br>            i--;<br>        &#125;<br>        <span class="hljs-comment">//循环结束，说明找到了插入位置，插入即可</span><br>        <span class="hljs-keyword">if</span> (i != low - <span class="hljs-number">1</span>) &#123;<br>            a[i + <span class="hljs-number">1</span>] = t;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 合并有序数组</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a1 原始数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i  iEnd 第一个有序范围</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> j  jEnd 第二个有序范围</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a2 临时数组</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a1, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> iEnd, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> jEnd, <span class="hljs-type">int</span>[] a2)</span> &#123;<br>    <span class="hljs-comment">//定义变量k为操作临时数组的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i;<br>    <span class="hljs-comment">//如果i和j都在有效范围内</span><br>    <span class="hljs-keyword">while</span> (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) &#123;<br>        <span class="hljs-comment">//比较i和j处索引的数组的值，并把较小的值加入到临时数组a2中</span><br>        <span class="hljs-keyword">if</span> (a1[i] &lt; a1[j]) &#123;<br>            a2[k] = a1[i];<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            a2[k] = a1[j];<br>            j++;<br>        &#125;<br>        <span class="hljs-comment">//更新操作临时数组的指针</span><br>        k++;<br>    &#125;<br>    <span class="hljs-comment">// 当i &gt; iEnd说明第一个有序范围内的元素已经全部迭代，将第二范围内没有被迭代的元素拷贝到a1数组即可</span><br>    <span class="hljs-keyword">if</span> (i &gt; iEnd) &#123;<br>        System.arraycopy(a1, j, a2, k, jEnd - j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 当j &gt; jEnd说明第二个有序范围内的元素已经全部迭代，将第一范围内没有被迭代的元素拷贝到a1数组即可</span><br>    <span class="hljs-keyword">if</span> (j &gt; jEnd) &#123;<br>        System.arraycopy(a1, i, a2, k, iEnd - i + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Zt7Bs">5.算法分析</h2>
+ **<font style="color:rgb(44, 62, 80);">稳定性</font>**<font style="color:rgb(44, 62, 80);">：稳定</font>
+ **<font style="color:rgb(44, 62, 80);">时间复杂度</font>**<font style="color:rgb(44, 62, 80);">：最佳：</font>_**<font style="color:#ED740C;">𝑂(𝑛𝑙𝑜𝑔𝑛)</font>**_<font style="color:rgb(44, 62, 80);">， 最差：</font>_**<font style="color:#ED740C;">𝑂(𝑛𝑙𝑜𝑔𝑛)</font>**_<font style="color:rgb(44, 62, 80);">， 平均：</font>_**<font style="color:#ED740C;">𝑂(𝑛𝑙𝑜𝑔𝑛)</font>**_
+ **<font style="color:rgb(44, 62, 80);">空间复杂度</font>**<font style="color:rgb(44, 62, 80);">：</font>_**<font style="color:#ED740C;">O(n)</font>**_



<h1 id="jeNDc">六：快速排序(quick sort)</h1>
**<font style="color:#ED740C;">快速排序（quick sort）</font>**<font style="color:rgb(29, 29, 32);">又称分区交换排序，是一种基于</font>**<font style="color:#601BDE;">分治策略</font>**<font style="color:rgb(29, 29, 32);">的排序算法，简称「快排」，运行高效，应用广泛。快速排序用到了分治思想，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，</font>**<font style="color:rgb(29, 29, 32);">划分的不定性使得快速排序的时间复杂度并不稳定。</font>**

<p><strong><font style="color:rgb(29, 29, 32);">快速排序的基本思想：</font></strong><font style="color:rgb(29, 29, 32);">通过一趟排序将待排序列分隔成独立的两部分，</font><strong><font style="color:rgb(29, 29, 32);background-color:#FBDE28;">其中一部分记录的元素均比另一部分的元素小</font></strong><font style="color:rgb(29, 29, 32);">，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</font></p>
<p><font style="color:rgb(29, 29, 32);">快速排序的核心操作是“</font><strong><font style="color:rgb(29, 29, 32);">哨兵划分</font></strong><font style="color:rgb(29, 29, 32);">”，其目标是：选择数组中的某个元素作为“</font><strong><font style="color:rgb(29, 29, 32);">基准数</font></strong><font style="color:rgb(29, 29, 32);">”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。具体来说，哨兵划分的流程如图下图所示。（</font><strong><font style="color:rgb(29, 29, 32);">图示只是快速排序算法中其中一种分区方法，具体的其他分区方法将在下面介绍</font></strong><font style="color:rgb(29, 29, 32);">）</font></p>
<ol>
<li><font style="color:rgb(29, 29, 32);">选取数组最左端元素作为基准数，初始化两个指针 </font>i<font style="color:rgb(29, 29, 32);"> 和 </font>j<font style="color:rgb(29, 29, 32);"> 分别指向数组的两端。</font></li>
<li><font style="color:rgb(29, 29, 32);">设置一个循环，在每轮中使用 </font>i<font style="color:rgb(29, 29, 32);">（</font>j<font style="color:rgb(29, 29, 32);">）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</font></li>
<li><font style="color:rgb(29, 29, 32);">循环执行步骤 </font>2.<font style="color:rgb(29, 29, 32);"> ，直到 </font>i<font style="color:rgb(29, 29, 32);"> 和 </font>j<font style="color:rgb(29, 29, 32);"> 相遇时停止，最后将基准数交换至两个子数组的分界线。</font></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713939661537-0690c2f0-6c54-4cbc-ad1c-fe75baafded6.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713939674764-df5f7aee-8624-4fba-98f4-fd1670b5108a.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713939763311-4d8e1c6c-a771-4874-a639-90bd0c1be074.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940443983-0808c12f-43af-4dad-ad0f-9c5808a222f3.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940440974-43bf6ded-6835-4da2-85f6-51c07572a51d.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940436983-49897f44-e025-4a7c-875e-40506bbb8bcb.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940433562-635834c6-963a-4e1d-a3b8-ad6d1fc486d4.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940419785-830b65cb-5cda-46f8-bb45-1b81c2f67484.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940411107-149c3e22-bb5f-44de-9f63-b8782f68fb5f.png" srcset="/img/loading.gif" lazyload alt="image">  </p>
<p><font style="color:rgb(29, 29, 32);">哨兵划分完成后，原数组被划分成三部分：</font><strong><font style="color:rgb(29, 29, 32);">左子数组</font></strong><font style="color:rgb(29, 29, 32);">、</font><strong><font style="color:rgb(29, 29, 32);">基准数</font></strong><font style="color:rgb(29, 29, 32);">、</font><strong><font style="color:rgb(29, 29, 32);">右子数组</font></strong><font style="color:rgb(29, 29, 32);">，且满足</font><strong><font style="color:rgb(29, 29, 32);">“左子数组任意元素 ≤ 基准数 ≤ 右子数组任意元素”</font></strong><font style="color:rgb(29, 29, 32);">。因此，我们接下来只需对这两个子数组进行排序。</font></p>
<p>:::color1<br><strong><font style="color:rgb(29, 29, 32);">快速排序的分治策略：</font></strong></p>
<p><font style="color:rgb(29, 29, 32);">哨兵划分的实质是将一个较长数组的排序问题简化为两个较短数组的排序问题。</font></p>
<p>:::</p>
<h2 id="AHhwl"><font style="color:rgb(29, 29, 32);">1.算法步骤</font></h2>
<font style="color:rgb(29, 29, 32);">快速排序的整体流程如下图所示。</font>

<ol>
<li><font style="color:rgb(29, 29, 32);">首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。</font></li>
<li><font style="color:rgb(29, 29, 32);">然后，对左子数组和右子数组分别递归执行“哨兵划分”。</font></li>
<li><font style="color:rgb(29, 29, 32);">持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序。</font></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713940998181-53b30a13-4fea-48eb-a732-87d78cbffaa2.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="jsd83">2.动图演示</h2>
![](https://cdn.nlark.com/yuque/0/2024/gif/40730112/1713941078916-74678641-2774-4587-8636-5a993efd7f8a.gif)

<h2 id="Gqj2Y">3.<font style="color:rgb(29, 29, 32);">快速排序为什么快</font></h2>
<font style="color:rgb(29, 29, 32);">从名称上就能看出，快速排序在效率方面应该具有一定的优势。尽管快速排序的平均时间复杂度与“归并排序”和“堆排序”相同，但通常快速排序的效率更高，主要有以下原因。</font>

<p>:::color1</p>
<ul>
<li><strong><font style="color:rgb(29, 29, 32);">出现最差情况的概率很低</font></strong><font style="color:rgb(29, 29, 32);">：虽然快速排序的最差时间复杂度为 </font><em><strong><font style="color:#ED740C;">𝑂(𝑛</font></strong></em><sup><em><strong><font style="color:#ED740C;">2</font></strong></em></sup><em><strong><font style="color:#ED740C;">) </font></strong></em><font style="color:rgb(29, 29, 32);">，没有归并排序稳定，但在绝大多数情况下，快速排序能在</font><em><strong><font style="color:#ED740C;"> 𝑂(𝑛log⁡𝑛) </font></strong></em><font style="color:rgb(29, 29, 32);">的时间复杂度下运行。</font></li>
<li><strong><font style="color:rgb(29, 29, 32);">缓存使用效率高</font></strong><font style="color:rgb(29, 29, 32);">：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性。</font></li>
<li><strong><font style="color:rgb(29, 29, 32);">复杂度的常数系数小</font></strong><font style="color:rgb(29, 29, 32);">：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的原因类似。</font></li>
</ul>
<p>:::</p>
<h2 id="bHi91">4.算法优化</h2>
<h3 id="qzYI7"><font style="color:rgb(29, 29, 32);">基准数优化</font></h3>
**<font style="color:rgb(29, 29, 32);">快速排序在某些输入下的时间效率可能降低</font>**<font style="color:rgb(29, 29, 32);">。举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为 𝑛−1、右子数组长度为 0 。如此递归下去，每轮哨兵划分后都有一个子数组的长度为 0 ，分治策略失效，快速排序退化为“冒泡排序”的近似形式。</font>

<p><font style="color:rgb(29, 29, 32);">为了尽量避免这种情况发生，</font><strong><font style="color:rgb(29, 29, 32);">我们可以优化哨兵划分中的基准数的选取策略</font></strong><font style="color:rgb(29, 29, 32);">。例如，我们可以</font><font style="color:rgb(29, 29, 32);background-color:#FBDE28;">随机选取</font><font style="color:rgb(29, 29, 32);">一个元素作为基准数。然而，如果运气不佳，每次都选到不理想的基准数，效率仍然不尽如人意。</font></p>
<p><font style="color:rgb(29, 29, 32);">需要注意的是，编程语言通常生成的是“伪随机数”。如果我们针对伪随机数序列构建一个特定的测试样例，那么快速排序的效率仍然可能劣化。</font></p>
<p><font style="color:rgb(29, 29, 32);">为了进一步改进，我们可以在数组中选取三个候选元素（通常为数组的首、尾、中点元素），</font><strong><font style="color:rgb(29, 29, 32);">并将这三个候选元素的中位数作为基准数</font></strong><font style="color:rgb(29, 29, 32);">。这样一来，基准数“既不太小也不太大”的概率将大幅提升。当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至 𝑂(𝑛</font><sup><font style="color:rgb(29, 29, 32);">2</font></sup><font style="color:rgb(29, 29, 32);">) 的概率大大降低。示例代码如下：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 选取三个候选元素的中位数 */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">medianThree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> nums[left], m = nums[mid], r = nums[right];<br>    <span class="hljs-keyword">if</span> ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))<br>        <span class="hljs-keyword">return</span> mid; <span class="hljs-comment">// m 在 l 和 r 之间</span><br>    <span class="hljs-keyword">if</span> ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))<br>        <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// l 在 m 和 r 之间</span><br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br><br><span class="hljs-comment">/* 哨兵划分（三数取中值） */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-comment">// 选取三个候选元素的中位数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">med</span> <span class="hljs-operator">=</span> medianThree(nums, left, (left + right) / <span class="hljs-number">2</span>, right);<br>    <span class="hljs-comment">// 将中位数交换至数组最左端</span><br>    swap(nums, left, med);<br>    <span class="hljs-comment">// 以 nums[left] 为基准数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left, j = right;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])<br>        j--;          <span class="hljs-comment">// 从右向左找首个小于基准数的元素</span><br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])<br>        i++;          <span class="hljs-comment">// 从左向右找首个大于基准数的元素</span><br>        swap(nums, i, j); <span class="hljs-comment">// 交换这两个元素</span><br>    &#125;<br>    swap(nums, i, left);  <span class="hljs-comment">// 将基准数交换至两子数组的分界线</span><br>    <span class="hljs-keyword">return</span> i;             <span class="hljs-comment">// 返回基准数的索引</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="SRyYY"><font style="color:rgb(29, 29, 32);">尾递归优化</font></h3>
**<font style="color:rgb(29, 29, 32);">在某些输入下，快速排序可能占用空间较多。</font>**<font style="color:rgb(29, 29, 32);">以完全有序的输入数组为例，设递归中的子数组长度为 𝑚 ，每轮哨兵划分操作都将产生长度为 0 的左子数组和长度为 𝑚−1 的右子数组，这意味着每一层递归调用减少的问题规模非常小（只减少一个元素），递归树的高度会达到 𝑛−1 ，此时需要占用 𝑂(𝑛) 大小的栈帧空间。</font>

<p><font style="color:rgb(29, 29, 32);">为了防止栈帧空间的累积，我们可以在每轮哨兵排序完成后，比较两个子数组的长度，</font><strong><font style="color:rgb(29, 29, 32);">仅对较短的子数组进行递归。</font></strong><font style="color:rgb(29, 29, 32);">由于较短子数组的长度不会超过 𝑛&#x2F;2 ，因此这种方法能确保递归深度不超过 log⁡𝑛 ，从而将最差空间复杂度优化至 𝑂(log⁡𝑛) 。代码如下所示：</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-comment">// 子数组长度为 1 时终止</span><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-comment">// 哨兵划分操作</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> partition(nums, left, right);<br>        <span class="hljs-comment">// 对两个子数组中较短的那个执行快速排序</span><br>        <span class="hljs-keyword">if</span> (pivot - left &lt; right - pivot) &#123;<br>            quickSort(nums, left, pivot - <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归排序左子数组</span><br>            left = pivot + <span class="hljs-number">1</span>; <span class="hljs-comment">// 剩余未排序区间为 [pivot + 1, right]</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            quickSort(nums, pivot + <span class="hljs-number">1</span>, right); <span class="hljs-comment">// 递归排序右子数组</span><br>            right = pivot - <span class="hljs-number">1</span>; <span class="hljs-comment">// 剩余未排序区间为 [left, pivot - 1]</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="JNd89">5.代码实现</h2>
<h3 id="UO2vj">单边循环快排</h3>
:::color1
**<font style="color:rgb(0, 0, 0);">单边循环（lomuto分区）</font>****<font style="color:rgba(96,27,222,1);">要点</font>**💥

<ul>
<li><font style="color:black;">选择最右侧元素作为基准点</font></li>
<li><font style="color:black;">j 找比基准点小的，i 找比基准点大的，一旦找到，二者进行交换</font><ul>
<li><font style="color:black;">交换时机：j 找到小的，且与 i 不相等</font></li>
<li><font style="color:black;">i 找到 &gt;&#x3D; 基准点元素后，不应自增</font></li>
</ul>
</li>
<li><font style="color:black;">最后基准点与 i 交换，i 即为基准点最终索引</font></li>
</ul>
<p><strong><font style="color:rgb(0, 0, 0);">例：</font></strong></p>
<p><font style="color:rgb(0, 0, 0);">i 和 j 都从左边出发向右查找，i 找到比基准点4大的5，j找到比基准点小的2，停下来交换</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713945792665-c4280330-ddc5-4f4d-842c-20372503fed2.png" srcset="/img/loading.gif" lazyload></p>
<p><font style="color:rgb(0, 0, 0);">i 找到了比基准点大的5，j 找到比基准点小的3，停下来交换</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713945830029-aeff3220-9fa6-4191-94bc-1154ba03e2d9.png" srcset="/img/loading.gif" lazyload></p>
<p><font style="color:rgb(0, 0, 0);">j 到达right 处结束，right 与 </font><strong><font style="color:rgb(0, 0, 0);">i</font></strong><font style="color:rgb(0, 0, 0);"> 交换，一轮分区结束</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713945840461-da92a973-9aff-42ce-9967-27fb521601bc.png" srcset="/img/loading.gif" lazyload></p>
<p>:::</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    doQuickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doQuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 分区</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> partition(nums, left, right);<br>    doQuickSort(nums, left, p - <span class="hljs-number">1</span>);<br>    doQuickSort(nums, p + <span class="hljs-number">1</span>, right);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单边循环快排（lomuto 洛穆托分区方案）</span><br><span class="hljs-comment">     * 核心思想：每轮找到一个基准点元素，把比它小的放到它左边，比它大的放到它右边，这称为分区</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 	1.选择最右元素作为基准点元素</span><br><span class="hljs-comment">     * 	2.j 找比基准点小的，i 找比基准点大的，一旦找到，二者进行交换</span><br><span class="hljs-comment">     * 		· 交换时机：j 找到小的，且与 i 不相等</span><br><span class="hljs-comment">     * 		· i 找到 &gt;= 基准点元素后，不应自增 </span><br><span class="hljs-comment">     * 	3.最后基准点与 i 交换，i 即为基准点最终索引</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> nums[right]; <span class="hljs-comment">// 选择最右元素作为基准点元素</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; <span class="hljs-comment">// i找比基准点大的值，如果找到大于等于基准点的值，不再移动</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> left; <span class="hljs-comment">// j找比基准点小的值</span><br>    <span class="hljs-keyword">while</span> (j &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (nums[j] &lt; pv) &#123; <span class="hljs-comment">// j找到小的了</span><br>            <span class="hljs-keyword">if</span> (j != i) &#123;<br>                swap(nums, i, j); <span class="hljs-comment">// i和j不一样，则交换</span><br>            &#125;<br>            <span class="hljs-comment">// 只有找到的值比基准点小,i才++，如果大于基准点的值,i不变,j++</span><br>            <span class="hljs-comment">// 等到下次找到比基准点小的值,i和j不相等，进行交换</span><br>            i++;<br>        &#125;<br>        j++;<br>    &#125;<br>    swap(nums, right, i);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = t;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="s4H8w">双边循环快排</h3>
:::color1
**<font style="color:rgb(0, 0, 0);">双边循环</font>****<font style="color:rgba(96,27,222,1);">要点</font>**💥

<ul>
<li><font style="color:black;">选择最左侧元素作为基准点</font></li>
<li><font style="color:black;">j 找比基准点小的，i 找比基准点大的，一旦找到，二者进行交换</font><ul>
<li><font style="color:black;">i 从左向右</font></li>
<li><font style="color:black;">j 从右向左</font></li>
</ul>
</li>
<li><font style="color:black;">最后基准点与 i 交换，i 即为基准点最终索引</font></li>
<li><strong><font style="color:black;">为什么最后 i 为基准点的最终索引？</font></strong><font style="color:black;">因为基准点在最左侧，那么就需要比基准点小的和它交换，而 i 指针指向的恰好为和 j 交换来的小于基准点的数</font></li>
</ul>
<p><strong><font style="color:rgb(0, 0, 0);">例：</font></strong></p>
<p><font style="color:rgb(0, 0, 0);">i 找到比基准点大的5停下来，j 找到比基准点小的1停下来（包含等于），二者交换</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713945962154-22998e8f-1e61-411f-988e-a8fc01082318.png" srcset="/img/loading.gif" lazyload></p>
<p><font style="color:rgb(0, 0, 0);">i 找到8，j 找到3，二者交换，i 找到7，j 找到2，二者交换</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713945969555-b11b9652-fe8b-472e-a0f7-0abd6b7a8259.png" srcset="/img/loading.gif" lazyload></p>
<p><font style="color:rgb(0, 0, 0);">i &#x3D;&#x3D; j，退出循环，基准点与 i 交换</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713945976129-27677173-9db7-4b75-9ccc-257a2fb8aacb.png" srcset="/img/loading.gif" lazyload></p>
<p>:::</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    doQuickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doQuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> partition(nums, left, right);<br>    doQuickSort(nums, left, p - <span class="hljs-number">1</span>);<br>    doQuickSort(nums, p + <span class="hljs-number">1</span>, right);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 双边循环快排</span><br><span class="hljs-comment">     * 1.选择最左元素作为基准点元素 </span><br><span class="hljs-comment">     * 2.j 指针负责从右向左找比基准点小或等的元素，i 指针负责从左向右找比基准点大的元素，</span><br><span class="hljs-comment">                                                     一旦找到二者交换，直至 i，j 相交</span><br><span class="hljs-comment">     * 3.最后基准点与 i（此时 i 与 j 相等）交换，i 即为分区位置</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-comment">/***************************随机元素作为基准点***************************/</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current().nextInt(right - left + <span class="hljs-number">1</span>) + left;<br>    swap(nums,index,left);<br>    <span class="hljs-comment">/***************************随机元素作为基准点***************************/</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> nums[left]; <span class="hljs-comment">// 选择最左侧元素作为基准点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left; <span class="hljs-comment">// i 指针从左到右找大于基准点的值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right; <span class="hljs-comment">// j 指针从右到左找小于基准点的值</span><br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-comment">// 必须先处理j指针再处理i指针</span><br>        <span class="hljs-comment">// 1. j 从右向左找小(等)的</span><br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt; pv) &#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 2. i 从左向右找大的</span><br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pv) &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 3. 交换位置</span><br>        swap(nums, i, j);<br>    &#125;<br>    swap(nums, left, i);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = t;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="jxgZU">随机基准点+处理重复值 双边循环快速排序</h3>
:::color1
**<font style="color:rgb(0, 0, 0);">随机基准点或者使用</font>****<font style="color:rgb(29, 29, 32);">三个候选元素</font>****<font style="color:rgb(0, 0, 0);">：</font>**

<p><font style="color:rgb(0, 0, 0);">使用随机数作为基准点，避免万一最大值或最小值作为基准点导致的分区不均衡</font></p>
<p><font style="color:rgb(29, 29, 32);">使用多个候选元素取中位数的方式，基准数“既不太小也不太大”的概率将大幅提升。</font></p>
<p><strong><font style="color:rgb(0, 0, 0);">例如：</font></strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713946141870-c2307dac-c7f9-4641-994e-165dbd9b021f.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>处理重复值：</strong></p>
<p><font style="color:rgb(0, 0, 0);">如果重复值较多，则原来算法中的分区效果也不好，如下图中左侧所示，需要想办法改为右侧的分区效果</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1713946270491-276cc0a5-168d-4655-af67-53c2361565aa.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><font style="color:black;">核心思想是</font><ul>
<li><font style="color:black;">改进前，i 只找大于的，j 会找小于等于的。一个不找等于、一个找等于，势必导致等于的值分布不平衡</font></li>
<li><font style="color:black;">改进后，二者都会找等于的交换，等于的值会平衡分布在基准点两边</font></li>
</ul>
</li>
<li><font style="color:black;">细节：</font><ul>
<li><font style="color:black;">因为一开始 i 就可能等于 j，因此外层循环需要加等于条件保证至少进入一次，让 j 能减到正确位置</font></li>
<li><font style="color:black;">内层 while 循环中 i &lt;&#x3D; j 的 &#x3D; 也不能去掉，因为 i &#x3D;&#x3D; j 时也要做一次与基准点的判断，好让 i 及 j 正确</font></li>
<li><font style="color:black;">i &#x3D;&#x3D; j 时，也要做一次 i++ 和 j– 使下次循环二者不等才能退出</font></li>
<li><strong><font style="color:black;">因为最后退出循环时 i 会大于 j，</font>****<font style="color:rgba(96,27,222,1);">因此最终与基准点交换的是 j </font></strong>💥💥💥</li>
</ul>
</li>
<li><font style="color:black;">内层两个 while 循环的先后顺序不再重要</font></li>
</ul>
<p>:::</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    doQuickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doQuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &gt;= right) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> partition(nums, left, right);<br>    doQuickSort(nums, left, p - <span class="hljs-number">1</span>);<br>    doQuickSort(nums, p + <span class="hljs-number">1</span>, right);<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">核心思想是</span><br><span class="hljs-comment">* 改进前，i 只找大于的，j 会找小于等于的。一个不找等于、一个找等于，势必导致等于的值分布不平衡</span><br><span class="hljs-comment">* 改进后，二者都会找等于的交换，等于的值会平衡分布在基准点两边</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-comment">// 随机基准点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current().nextInt(right - left + <span class="hljs-number">1</span>) + left;<br>    swap(nums, left, random);<br>    <span class="hljs-comment">// 基准点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> nums[left];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>; <span class="hljs-comment">// 在处理重复值时,i要从left + 1开始</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> right;<br>    <span class="hljs-keyword">while</span> (i &lt;= j) &#123;<br>        <span class="hljs-comment">// i 指针和 j 指针的先后处理方式不再重要</span><br>        <span class="hljs-comment">// 处理重复值，i需要从左到右找大于等于基准点的值</span><br>        <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[i] &lt; pv) &#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 处理重复值，j需要从右向左找小于等于基准点的值</span><br>        <span class="hljs-keyword">while</span> (i &lt;= j &amp;&amp; nums[j] &gt; pv) &#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &lt;= j) &#123;<br>            swap(nums, i, j);<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>    swap(nums, j, left);<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = t;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="yuqbF">6.算法分析</h2>
+ **<font style="color:rgb(44, 62, 80);">稳定性</font>**<font style="color:rgb(44, 62, 80);">：</font>**<font style="color:#DF2A3F;">不稳定</font>**
+ **<font style="color:rgb(44, 62, 80);">时间复杂度</font>**<font style="color:rgb(44, 62, 80);">：最佳：</font>_**<font style="color:#ED740C;">𝑂(𝑛𝑙𝑜𝑔𝑛)</font>**_<font style="color:rgb(44, 62, 80);">， 最差：</font>_**<font style="color:#ED740C;">𝑂(n</font>**_<sup>_**<font style="color:#ED740C;">2</font>**_</sup>_**<font style="color:#ED740C;">)</font>**_<font style="color:rgb(44, 62, 80);">，平均：</font>_**<font style="color:#ED740C;">𝑂(𝑛𝑙𝑜𝑔𝑛)</font>**_
+ **<font style="color:rgb(44, 62, 80);">空间复杂度</font>**<font style="color:rgb(44, 62, 80);">：</font>_**<font style="color:#ED740C;">𝑂(𝑛𝑙𝑜𝑔𝑛)</font>**_

<h1 id="jxYN6">七：堆排序(Heap Sort)</h1>
**<font style="color:#ED740C;">堆排序</font>**<font style="color:rgb(44, 62, 80);">是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足</font>**<font style="color:rgb(44, 62, 80);">堆的性质</font>**<font style="color:rgb(44, 62, 80);">：即</font>**<font style="color:rgb(44, 62, 80);">子结点的值总是小于（或者大于）它的父节点</font>**<font style="color:rgb(44, 62, 80);">。</font>

<p><font style="color:rgb(29, 29, 32);">我们可以利用已经学过的</font><strong><font style="color:rgb(29, 29, 32);">“建堆操作”</font></strong><font style="color:rgb(29, 29, 32);">和</font><strong><font style="color:rgb(29, 29, 32);">“元素出堆操作”</font></strong><font style="color:rgb(29, 29, 32);">实现堆排序。</font></p>
<ol>
<li><font style="color:rgb(29, 29, 32);">输入数组并建立小顶堆，此时最小元素位于堆顶。</font></li>
<li><font style="color:rgb(29, 29, 32);">不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列。</font></li>
</ol>
<p><font style="color:rgb(29, 29, 32);">以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式。</font></p>
<p>:::color1<br>**<font style="color:#ED740C;">堆排序</font><strong>在一定程度上有着与</strong><font style="color:#ED740C;">选择排序</font>**类似的思想，也是每次在数组中选择最大的元素的值然后交换到数组的最后一位，最终实现有序，但是传统的选择排序在选择最大值的过程中采用的是遍历比较，每次选择最大值都需要遍历未排序区域，但是，想要选择最大值，堆数据结构是一个非常合适的解决方法，我们将数据构建为堆数据结构，每次选择最大值只需要拿到堆顶元素即可，然后对堆做一次下潜操作，继续构建堆结构。</p>
<p>:::</p>
<h2 id="w4xAp">1.算法步骤</h2>
设数组的长度为 𝑛 ，堆排序的流程如下图所示。

<ol>
<li>输入数组并建立大顶堆。完成后，最大元素位于堆顶。</li>
<li>将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 1 ，已排序元素数量加 1 。</li>
<li>从堆顶元素开始，从顶到底执行堆化操作（sift down）。完成堆化后，堆的性质得到修复。</li>
<li>循环执行第 2. 步和第 3. 步。循环 𝑛−1 轮后，即可完成数组排序。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034222739-60b40e6b-64b1-495c-a668-80798112bd81.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034228904-690d0fe9-7b30-48ce-a610-aff18661d46b.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034241328-bf95dbf9-509c-421d-a270-534102cb1f8f.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034243415-b2733349-93aa-4eab-bd10-721dab665562.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034245611-85448aed-4611-4366-945d-d7f6a5fac143.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034248903-1b9d95e0-a962-42cf-ad8c-532530889672.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034252757-973e0d98-60d9-4f85-9751-45e2669bd05d.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034257715-798fbb4d-89ec-43c6-b198-c4dea55faf3e.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034262409-98a52a34-b7de-4536-b48f-4b74ffed9207.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034269010-bc3e8a7c-66c4-4d07-8b21-6825e5620ea0.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034271915-ef40ea7f-5ee9-4b32-b612-7b22bd7ccc2e.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714034274565-666a6742-27a4-45e4-a621-a30d4444505e.png" srcset="/img/loading.gif" lazyload alt="image">  </p>
<p>在代码实现中，使用了与“堆”相同的从顶至底堆化 sift_down() 函数。值得注意的是，由于堆的长度会随着提取最大元素而减小，因此我们需要给 sift_down() 函数添加一个长度参数 𝑛 ，用于指定堆的当前有效长度。代码如下所示：</p>
<h2 id="BLIhY">2.动图演示</h2>
![](https://cdn.nlark.com/yuque/0/2024/gif/40730112/1714034345413-dd9d5ee2-42cd-436a-a3b1-afc91033a40b.gif)

<h2 id="oNgW3">3.代码实现</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>    <span class="hljs-comment">//建立大顶堆</span><br>    heapify(a, a.length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> a.length - <span class="hljs-number">1</span>; right &gt; <span class="hljs-number">0</span>; right--) &#123;<br>        swap(a, <span class="hljs-number">0</span>, right); <span class="hljs-comment">//交换堆顶元素到未排序区域的最后一位（将最大值移动到最后）</span><br>        down(a, <span class="hljs-number">0</span>, right); <span class="hljs-comment">//对于堆顶元素进行下潜操作，使其重新符合大顶堆特性</span><br>    &#125;<br>&#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 建推</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1.找到完全二叉树的最后一个非叶子节点     公式： size / 2 - 1</span><br><span class="hljs-comment">        2.从后向前，依次对每个非叶子节点调用下潜down方法</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (size &gt;&gt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        down(array, i, size);<br>    &#125;<br>&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下潜 &lt;非递归实现&gt;</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> parent, <span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1.找到当前节点的左孩子节点和右孩子节点</span><br><span class="hljs-comment">    2.将当前节点的值和左孩子，右孩子的值进行比较</span><br><span class="hljs-comment">    3.定义一个变量max，用于存放当前节点与其左右孩子中最大的值的下标</span><br><span class="hljs-comment">    4.默认最大值先为当前节点，如果左孩子的值大于当前节点，更新max指针为左孩子下标，右孩子类似</span><br><span class="hljs-comment">    5.经过比较，如果max指针任然为父节点，说明没有发生交换，已经符合大顶堆特性，退出循环即可</span><br><span class="hljs-comment">    6.如果max不为父节点，交换当前父节点与max指针指向的节点的值，将max赋值给父节点，循环继续判断是否仍需要下潜</span><br><span class="hljs-comment">         */</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> parent;<br>        <span class="hljs-keyword">if</span> (left &lt; size &amp;&amp; array[left] &gt; array[max]) &#123;<br>            max = left;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp; array[right] &gt; array[max]) &#123;<br>            max = right;<br>        &#125;<br>        <span class="hljs-comment">// 没有发生交换</span><br>        <span class="hljs-keyword">if</span> (max == parent) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        swap(array, max, parent);<br>        parent = max;<br>    &#125;<br>&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 交换</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> array[i];<br>    array[i] = array[j];<br>    array[j] = t;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ONrfv">4.算法分析</h2>
+ **<font style="color:rgb(44, 62, 80);">稳定性</font>**<font style="color:rgb(44, 62, 80);">：</font>**<font style="color:#DF2A3F;">不稳定</font>**
+ **<font style="color:rgb(44, 62, 80);">时间复杂度</font>**<font style="color:rgb(44, 62, 80);">：最佳：</font>_**<font style="color:#ED740C;">𝑂(𝑛𝑙𝑜𝑔𝑛)</font>**_<font style="color:rgb(44, 62, 80);">， 最差：</font>_**<font style="color:#ED740C;">𝑂(𝑛𝑙𝑜𝑔𝑛)</font>**_<font style="color:rgb(44, 62, 80);">， 平均：</font>_**<font style="color:#ED740C;">𝑂(𝑛𝑙𝑜𝑔𝑛)</font>**_
+ **<font style="color:rgb(44, 62, 80);">空间复杂度</font>**<font style="color:rgb(44, 62, 80);">：</font>_**<font style="color:#ED740C;">O(1)</font>**_

<p><em><strong><font style="color:#ED740C;"></font></strong></em></p>
<h1 id="XUClQ">八：计数排序 (Counting Sort)</h1>
**<font style="color:#ED740C;">计数排序（counting sort）</font>**<font style="color:rgb(44, 62, 80);">通过</font>**<font style="color:rgb(44, 62, 80);">统计元素数量来实现排序</font>**<font style="color:rgb(44, 62, 80);">，通常应用于整数数组。</font>

<p><font style="color:rgb(44, 62, 80);">计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种</font><strong><font style="color:rgb(44, 62, 80);">线性时间</font></strong><font style="color:rgb(44, 62, 80);">复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</font></p>
<p><font style="color:rgb(44, 62, 80);">计数排序 (Counting sort) 是一种</font><strong><font style="color:rgb(44, 62, 80);">稳定</font></strong><font style="color:rgb(44, 62, 80);">的排序算法。计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序。</font></p>
<h2 id="u6hrG">1.算法步骤</h2>
<font style="color:rgb(44, 62, 80);">先来看一个简单的例子。给定一个长度为 𝑛 的数组 nums ，其中的元素都是“非负整数”，计数排序的整体流程如下图所示。</font>

<ol>
<li><font style="color:rgb(44, 62, 80);">遍历数组，找出其中的最大数字，记为 𝑚 ，然后创建一个长度为 𝑚+1 的</font><strong><font style="color:rgb(44, 62, 80);">辅助数组 </font></strong><font style="color:rgb(44, 62, 80);">counter 。</font></li>
<li><font style="color:rgb(44, 62, 80);">借助 counter </font><strong><font style="color:rgb(44, 62, 80);">统计 nums 中各数字的出现次数</font></strong><font style="color:rgb(44, 62, 80);">，其中 counter[num] 对应数字 num 的出现次数。统计方法很简单，只需遍历 nums（设当前数字为 num），每轮将 counter[num] 增加 1 即可。</font></li>
<li><font style="color:rgb(44, 62, 80);">由于 counter 的各个索引天然有序，因此相当于所有数字已经排序好了。接下来，我们遍历 counter ，根据各数字出现次数从小到大的顺序填入 nums 即可。</font></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714361611552-64455a6c-b48e-4426-8ca0-892c787f4a5b.png" srcset="/img/loading.gif" lazyload alt="计数排序流程"></p>
<blockquote>
<p><strong><font style="color:#601BDE;">(不可处理负数)要点：</font></strong>💥</p>
<p><strong>1. 找到最大值，创建一个大小为 最大值+1 的 count 数组</strong></p>
<p>**       2. count 数组的<strong><strong>索引对应原始数组的元素</strong></strong>，用来统计该元素的出现次数**</p>
<p>**       3. 遍历 count 数组，根据 count 数组的索引（即原始数组的元素）以及出现次数，生成排序后内容**</p>
<p>**           count 数组的索引是：已排序好的**</p>
<p>**     ****前提：**<strong>待排序元素 &gt;&#x3D;0 且最大值不能太大</strong></p>
<p><strong><font style="color:#601BDE;">(可处理负数)要点：</font></strong>💥</p>
<p><strong>1. 让原始数组的最小值<strong><strong>映射</strong></strong>到 count[0] 最大值映射到 count 最右侧</strong></p>
<p><strong>2. 原始数组元素 - 最小值 &#x3D; count 索引</strong></p>
<p><strong>3. count 索引 + 最小值 &#x3D; 原始数组元素</strong></p>
</blockquote>
<h2 id="b6hwG">2.动画演示</h2>
![](https://cdn.nlark.com/yuque/0/2024/gif/40730112/1714361654681-ca91e24c-3a7a-4989-8dbe-70dc644506fa.gif)

<h2 id="SDDI8">3.代码实现</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countingSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>    <span class="hljs-comment">// 1.获取数组最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; a.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; max) &#123;<br>            max = a[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 2.创建一个长度为数组最大值 + 1的新数组</span><br>    <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 3.遍历原始数组，将对应数据索引处的值++（统计该元素的出现次数）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : a) &#123;<br>        count[v]++;<br>    &#125;<br>    <span class="hljs-comment">//定义一个指针k操作原始数组</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 4.遍历count数组，将值大于0处的索引值添加到原始数组中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count.length; i++) &#123;<br>        <span class="hljs-keyword">while</span> (count[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            a[k++] = i;<br>            <span class="hljs-comment">// 5.添加完成后，对应索引处的值--（表示出现次数-1）</span><br>            count[i]--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a)</span> &#123;<br>    <span class="hljs-comment">// 1.遍历数组，拿到数组中的最大值和最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; a.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; max) &#123;<br>            max = a[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a[i] &lt; min) &#123;<br>            min = a[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 2.实例化一个数组长度为 max - min + 1 的新数组</span><br>    <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max - min + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 3.遍历原始数组，将原始数组中的(值 - min)与count数组索引做映射</span><br>    <span class="hljs-comment">// 可以通过值 - min的方式将所有数据全部映射为大于零的数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : a) &#123;<br>        count[v - min]++; <span class="hljs-comment">// v 原始数组元素 - 最小值 = count 索引</span><br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count.length; i++) &#123;<br>        <span class="hljs-keyword">while</span> (count[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// i + min 代表原始数组元素 count[i] 代表元素出现次数</span><br>            a[k++] = i + min;<br>            count[i]--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="kuhy4">4.完整实现</h2>
细心的读者可能发现了，如果**输入数据是对象**，上述步骤 `**3.**`** **就失效了。假设输入数据是商品对象，我们想按照商品价格（类的成员变量）对商品进行排序，而上述算法只能给出价格的排序结果。

<p>那么如何才能得到原数据的排序结果呢？我们首先计算 count 的**“前缀和”**。顾名思义，<strong>索引 i 处的前缀和 prefix[i] 等于数组前 i 个元素之和：</strong></p>
<p>$ prefix[i] &#x3D; \sum_{j&#x3D;0}^i count[j] $</p>
<p>**前缀和具有明确的意义，prefix[num] - 1 代表元素 num 在结果数组 res 中最后一次出现的索引。**这个信息非常关键，因为它告诉我们各个元素应该出现在结果数组的哪个位置。接下来，我们倒序遍历原数组 nums 的每个元素 num ，在每轮迭代中执行以下两步。</p>
<ol>
<li>将 num 填入数组 res 的索引 prefix[num] - 1 处。</li>
<li>令前缀和 prefix[num] 减小 1 ，从而得到下次放置 num 的索引。</li>
</ol>
<p>遍历完成后，数组 res 中就是排序好的结果，最后使用 res 覆盖原数组 nums 即可。下图展示了完整的计数排序流程。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379493320-e1596c3c-dace-4fc1-87ba-b8cfc31d703a.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379497443-ed2c6598-c7cc-4b08-bd41-f2467da12a40.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379510439-1fecd667-ce0d-422a-a8e6-6d1013c7827e.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379513809-258216d3-9de2-4a6b-8810-a355bc7eeaca.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379516309-fe4bf782-e113-4566-94c7-589495144202.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379520702-3b7f0245-7445-424d-908c-317de1cb7c44.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379523336-d82ba0d5-0916-488a-bc63-7ca31ab9bff9.png" srcset="/img/loading.gif" lazyload alt="image"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714379526923-0242d20f-8aef-40f0-8bba-cc6b98ca743a.png" srcset="/img/loading.gif" lazyload alt="image">  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// 1. 统计数组最大元素 max</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        max = Math.max(nums[i], max);<br>    &#125;<br>    <span class="hljs-comment">// 2. 统计各数字的出现次数</span><br>    <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        count[num]++;<br>    &#125;<br>    <span class="hljs-comment">// 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span><br>    <span class="hljs-type">int</span>[] prefix = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[count.length];<br>    prefix[<span class="hljs-number">0</span>] = count[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; prefix.length; i++) &#123;<br>        prefix[i] = count[i] + prefix[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// 4. 倒序遍历 nums ，将各元素填入结果数组 res</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> nums[i];<br>        res[prefix[num] - <span class="hljs-number">1</span>] = num;<br>        prefix[num]--;<br>    &#125;<br>    <span class="hljs-comment">// 使用结果数组 res 覆盖原数组 nums</span><br>    System.arraycopy(res, <span class="hljs-number">0</span>, nums, <span class="hljs-number">0</span>, nums.length);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="IS5UG">5.算法分析</h2>
当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是_**<font style="color:#ED740C;"> O(n+k)</font>**_。**计数排序不是比较排序，排序的速度快于任何比较排序算法。**由于用来计数的数组 C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量额外内存空间。

<ul>
<li><strong>稳定性：****<font style="color:#74B602;">稳定</font></strong></li>
<li><strong>时间复杂度：<strong>最佳：_</strong><font style="color:#ED740C;">O(n+k) </font></strong><em>最差：</em><strong><font style="color:#ED740C;">O(n+k) </font></strong><em>平均：</em><strong><font style="color:#ED740C;">O(n+k)</font></strong>_</li>
<li><strong>空间复杂度：</strong><em><strong><font style="color:#ED740C;">O(k)</font></strong></em></li>
</ul>
<p><em><strong><font style="color:#ED740C;"></font></strong></em></p>
<h1 id="KYVqH">九：桶排序(Bucket Sort)</h1>
**<font style="color:#ED740C;">桶排序（bucket sort）</font>**是**分治**策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，**在每个桶内部分别执行排序**；**最终按照桶的顺序将所有数据合并。**

<p>桶排序是计数排序的升级版。它利用了函数的映射关系，**高效与否的关键就在于这个映射函数的确定。**为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li><strong>在额外空间充足的情况下，尽量增大桶的数量</strong></li>
<li><strong>使用的映射函数能够将输入的 N 个数据</strong>**<font style="color:#74B602;">均匀</font>**<strong>的分配到 K 个桶中</strong></li>
</ol>
<p>桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行）</p>
<h2 id="QjLn4">1.算法步骤</h2>
考虑一个长度为 𝑛 的数组，其元素是范围** [0,1) **内的浮点数。桶排序的流程如下图所示。

<ol>
<li>初始化 𝑘 个桶，将 𝑛 个元素分配到 𝑘 个桶中。</li>
<li>对每个桶分别执行排序（这里采用编程语言的内置排序函数）。</li>
<li>按照桶从小到大的顺序合并结果。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714383034696-27b1204d-2a2d-4bb4-bcf5-6f101d676bd6.png" srcset="/img/loading.gif" lazyload alt="桶排序算法流程"></p>
<h2 id="qKKSb">2.动画演示</h2>
![](https://cdn.nlark.com/yuque/0/2024/gif/40730112/1714383095318-988b9c36-42d6-45a7-b0e7-231d8be75177.gif)

<h2 id="vHC0v">3.代码实现</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 桶排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums 待排序数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> range 每个桶中数据的最大范围</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> range)</span> &#123;<br>    <span class="hljs-comment">// 1. 先求最大值和最小值（高效确定桶的个数）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        max = Math.max(max, nums[i]);<br>        min = Math.min(min, nums[i]);<br>    &#125;<br>    <span class="hljs-comment">// 2. 初始化桶的个数   桶的数量为(max-min)/range + 1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">bucket_count</span> <span class="hljs-operator">=</span> (max - min) / range + <span class="hljs-number">1</span>;<br>    List&lt;List&lt;Integer&gt;&gt; buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bucket_count; i++) &#123;<br>        buckets.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    &#125;<br>    <span class="hljs-comment">// 遍历输入的数据 放入对应的桶中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-comment">// 计算当前元素应该存在在那个桶中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> (num - min) / range;<br>        buckets.get(idx).add(num);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;<br>        <span class="hljs-type">int</span>[] array = bucket.stream().mapToInt(Integer::intValue).toArray();<br>        <span class="hljs-comment">// 3.排序桶内元素</span><br>        Arrays.sort(array);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : array) &#123;<br>            nums[k++] = a;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="mkdvh">4.<font style="color:rgb(29, 29, 32);">如何实现平均分配</font></h2>
桶排序的时间复杂度理论上可以达到_**<font style="color:#ED740C;"> 𝑂(𝑛) </font>**_，**关键在于将元素均匀分配到各个桶中**，因为实际数据往往不是均匀分布的。例如，我们想要将淘宝上的所有商品按价格范围平均分配到 10 个桶中，但商品价格分布不均，低于 100 元的非常多，高于 1000 元的非常少。若将价格区间平均划分为 10 个，各个桶中的商品数量差距会非常大。

<p>为实现平均分配，我们可以先设定一条大致的分界线，将数据粗略地分到 3 个桶中。<strong>分配完毕后，再将商品较多的桶继续划分为 3 个桶，直至所有桶中的元素数量大致相等。</strong></p>
<p>如图所示，这种方法本质上是创建一棵<strong>递归树</strong>，目标是让叶节点的值尽可能平均。当然，不一定要每轮将数据划分为 3 个桶，具体划分方式可根据数据特点灵活选择。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714384908781-62c4e1f6-86cf-4e7f-bd2a-d0dacf12da92.png" srcset="/img/loading.gif" lazyload alt="递归划分桶"></p>
<p>如果我们提前知道商品价格的概率分布，**则可以根据数据概率分布设置每个桶的价格分界线。**值得注意的是，数据分布并不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似。</p>
<p>如下图所示，我们假设商品价格服从正态分布，这样就可以合理地设定价格区间，从而将商品平均分配到各个桶中。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714384908705-8eddc37d-88a7-4046-9767-b34742ebf4ff.png" srcset="/img/loading.gif" lazyload alt="根据概率分布划分桶"></p>
<h2 id="C7UgK">5.算法分析</h2>
+ **<font style="color:rgb(44, 62, 80);">稳定性</font>**<font style="color:rgb(44, 62, 80);">：稳定</font>
+ **<font style="color:rgb(44, 62, 80);">时间复杂度</font>**<font style="color:rgb(44, 62, 80);">：最佳：</font>_**<font style="color:#ED740C;">𝑂(𝑛+𝑘)</font>**_<font style="color:rgb(44, 62, 80);"> 最差：</font>_**<font style="color:#ED740C;">𝑂(𝑛</font>**_<sup>_**<font style="color:#ED740C;">2</font>**_</sup>_**<font style="color:#ED740C;">)</font>**_<font style="color:rgb(44, 62, 80);"> 平均：</font>_**<font style="color:#ED740C;">𝑂(𝑛+𝑘)</font>**_
+ **<font style="color:rgb(44, 62, 80);">空间复杂度</font>**<font style="color:rgb(44, 62, 80);">：</font>_**<font style="color:#ED740C;">𝑂(𝑛+𝑘)</font>**_

<h1 id="FPcpQ">十：基数排序（radix sort）</h1>
**基数排序（radix sort）**的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各**位**之间的递进关系，依次对**每一位**进行排序，从而得到最终的排序结果。

<p>基数排序也是<strong>非比较</strong>的排序算法，对元素中的每一位数字进行排序，<strong>从最低位开始排序</strong>，复杂度为 <em><strong><font style="color:#ED740C;">O(n×k)</font></strong></em>，n 为数组长度，k 为数组中元素的最大的位数；</p>
<p><strong>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；<strong>依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是</strong>稳定</strong>的。</p>
<p>在上面我们介绍了计数排序，它适用于数据量 𝑛 较大但数据范围 𝑚 较小的情况。假设我们需要对 𝑛&#x3D;10<sup>6 </sup>个学号进行排序，而学号是一个 8 位数字，这意味着数据范围 𝑚&#x3D;10<sup>8 </sup>非常大，使用计数排序需要分配大量内存空间，而基数排序可以避免这种情况。</p>
<h2 id="fTc23">1.算法步骤</h2>
以学号数据为例，假设数字的最低位是第 1 位，最高位是第 8 位，基数排序的流程如图所示。

<ol>
<li>初始化位数 𝑘&#x3D;1 。</li>
<li>对学号的第 𝑘 位执行“计数排序”。完成后，数据会根据第 𝑘 位从小到大排序。</li>
<li>将 𝑘 增加 1 ，然后返回步骤 2. 继续迭代，直到所有位都排序完成后结束。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714463575538-0ba43ec3-91c7-4347-9e76-2bb43f23c51e.png" srcset="/img/loading.gif" lazyload alt="基数排序算法流程"></p>
<p>下面剖析代码实现。对于一个 𝑑 进制的数字 𝑥 ，要获取其第 𝑘 位 𝑥<sub>𝑘</sub> ，可以使用以下计算公式：</p>
<p>$ 𝑥_𝑘&#x3D;⌊\frac{x}{d^{k-1}}⌋mod 𝑑 $</p>
<p>其中 ⌊𝑎⌋ 表示对浮点数 𝑎 向下取整，而 mod𝑑 表示对 𝑑 取模（取余）。对于学号数据，𝑑&#x3D;10 且 𝑘∈[1,8] </p>
<h2 id="qDRA4">2.动画演示</h2>
![](https://cdn.nlark.com/yuque/0/2024/gif/40730112/1714464078410-28cca461-f2cc-4ec4-b06f-39c78bfe3d83.gif)

<h2 id="MMY9m">3.代码实现</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(String[] a, <span class="hljs-type">int</span> length)</span> &#123;<br>    <span class="hljs-comment">// 1.准备桶</span><br>    ArrayList&lt;String&gt;[] buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>[<span class="hljs-number">128</span>];<br>    <span class="hljs-comment">// 2.初始化桶</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; buckets.length; i++) &#123;<br>        buckets[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-comment">// 3.从低位开始多轮桶排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 4.将字符串放入合适的桶</span><br>        <span class="hljs-keyword">for</span> (String v : a) &#123;<br>            buckets[v.charAt(i)].add(v);<br>        &#125;<br>        <span class="hljs-comment">// 5.重新取出排好序的字符串，放回原始数组</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (ArrayList&lt;String&gt; bucket : buckets) &#123;<br>            <span class="hljs-keyword">for</span> (String s : bucket) &#123;<br>                a[k++] = s;<br>            &#125;<br>            bucket.clear();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">digit</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> exp)</span> &#123;<br>    <span class="hljs-comment">// 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span><br>    <span class="hljs-keyword">return</span> (num / exp) % <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-comment">/* 计数排序（根据 nums 第 k 位排序） */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">countingSortDigit</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> exp)</span> &#123;<br>    <span class="hljs-comment">// 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组</span><br>    <span class="hljs-type">int</span>[] counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-comment">// 统计 0~9 各数字的出现次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> digit(nums[i], exp); <span class="hljs-comment">// 获取 nums[i] 第 k 位，记为 d</span><br>        counter[d]++;                <span class="hljs-comment">// 统计数字 d 的出现次数</span><br>    &#125;<br>    <span class="hljs-comment">// 求前缀和，将“出现个数”转换为“数组索引”</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        counter[i] += counter[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">// 倒序遍历，根据桶内统计结果，将各元素填入 res</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> digit(nums[i], exp);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> counter[d] - <span class="hljs-number">1</span>; <span class="hljs-comment">// 获取 d 在数组中的索引 j</span><br>        res[j] = nums[i];       <span class="hljs-comment">// 将当前元素填入索引 j</span><br>        counter[d]--;           <span class="hljs-comment">// 将 d 的数量减 1</span><br>    &#125;<br>    <span class="hljs-comment">// 使用结果覆盖原数组 nums</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>    nums[i] = res[i];<br>&#125;<br><br><span class="hljs-comment">/* 基数排序 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">// 获取数组的最大元素，用于判断最大位数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)<br>    <span class="hljs-keyword">if</span> (num &gt; m)<br>        m = num;<br>    <span class="hljs-comment">// 按照从低位到高位的顺序遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; exp &lt;= m; exp *= <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-comment">// 对数组元素的第 k 位执行计数排序</span><br>        <span class="hljs-comment">// k = 1 -&gt; exp = 1</span><br>        <span class="hljs-comment">// k = 2 -&gt; exp = 10</span><br>        <span class="hljs-comment">// 即 exp = 10^(k-1)</span><br>        countingSortDigit(nums, exp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<details class="lake-collapse"><summary id="u310d9d0e"><strong><span class="ne-text" style="color: rgb(42, 188, 191); font-size: 14px">为什么从最低位开始排序</span></strong><span class="ne-text">❓</span></summary><p id="ud237a580" class="ne-p"><span class="ne-text">在连续的排序轮次中，后一轮排序会覆盖前一轮排序的结果。举例来说，如果第一轮排序结果 𝑎&lt;𝑏 ，而第二轮排序结果 𝑎&gt;𝑏 ，那么第二轮的结果将取代第一轮的结果。由于数字的高位优先级高于低位，因此应该先排序低位再排序高位。</span></p></details>
<h2 id="WA1mE">4.算法分析</h2>
+ **稳定性：****<font style="color:#ED740C;">稳定</font>**
+ **时间复杂度：**最佳：_**<font style="color:#ED740C;">𝑂(𝑛×𝑘) </font>**_最差：_**<font style="color:#ED740C;">𝑂(𝑛×𝑘)</font>**_ 平均：_**<font style="color:#ED740C;">𝑂(𝑛×𝑘)</font>**_
+ **空间复杂度：**_**<font style="color:#ED740C;">𝑂(𝑛×𝑘)</font>**_



<p>:::success</p>
<h2 id="Vwp1E"><font style="color:rgb(44, 62, 80);">基数排序 vs 计数排序 vs 桶排序</font></h2>
<font style="color:rgb(44, 62, 80);">这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</font>

<ul>
<li><strong><font style="color:rgb(44, 62, 80);">基数排序：</font></strong><font style="color:rgb(44, 62, 80);">根据键值的每位数字来分配桶</font></li>
<li><strong><font style="color:rgb(44, 62, 80);">计数排序：</font></strong><font style="color:rgb(44, 62, 80);">每个桶只存储单一键值</font></li>
<li><strong><font style="color:rgb(44, 62, 80);">桶排序：</font></strong><font style="color:rgb(44, 62, 80);">每个桶存储一定范围的数值</font></li>
</ul>
<p>:::</p>
<h1 id="d6gVu">小结</h1>
<h2 id="iUBu0"><font style="color:rgb(29, 29, 32);">重点回顾</font></h2>
+ **冒泡排序通过交换相邻元素来实现排序。**通过添加一个标志位来实现提前返回，我们可以将冒泡排序的最佳时间复杂度优化到 𝑂(𝑛) 。
+ **插入排序每轮将未排序区间内的元素插入到已排序区间的正确位置，从而完成排序。**虽然插入排序的时间复杂度为 𝑂(𝑛<sup>2</sup>) ，但由于单元操作相对较少，因此在小数据量的排序任务中非常受欢迎。
+ **快速排序基于哨兵划分操作实现排序。**在哨兵划分中，有可能每次都选取到最差的基准数，导致时间复杂度劣化至 𝑂(𝑛<sup>2</sup>) 。引入中位数基准数或随机基准数可以降低这种劣化的概率。尾递归方法可以有效地减少递归深度，将空间复杂度优化到 𝑂(log⁡𝑛) 。
+ **归并排序包括划分和合并两个阶段，典型地体现了分治策略。**在归并排序中，排序数组需要创建辅助数组，空间复杂度为 𝑂(𝑛) ；然而排序链表的空间复杂度可以优化至 𝑂(1) 。
+ **桶排序包含三个步骤：数据分桶、桶内排序和合并结果。**它同样体现了分治策略，适用于数据体量很大的情况。桶排序的关键在于对数据进行平均分配。
+ **计数排序是桶排序的一个特例，它通过统计数据出现的次数来实现排序。**计数排序适用于数据量大但数据范围有限的情况，并且要求数据能够转换为正整数。
+ **基数排序通过逐位排序来实现数据排序，要求数据能够表示为固定位数的数字。**
+ 总的来说，我们希望找到一种排序算法，具有**高效率、稳定、原地以及正向自适应性**等优点。然而，正如其他数据结构和算法一样，没有一种排序算法能够同时满足所有这些条件。在实际应用中，我们需要根据数据的特性来选择合适的排序算法。
+ 下图对比了主流排序算法的效率、稳定性、就地性和自适应性等。

<p><img src="https://cdn.nlark.com/yuque/0/2024/png/40730112/1714466061550-c37ba78e-e921-48b7-902c-c8ccf966aad1.png" srcset="/img/loading.gif" lazyload alt="排序算法对比"></p>
<h2 id="MTWIP"><font style="color:rgb(29, 29, 32);">2.   Q & A</font></h2>
:::success
**Q：排序算法稳定性在什么情况下是必需的？**

<p>在现实中，我们有可能基于对象的某个属性进行排序。例如，学生有姓名和身高两个属性，我们希望实现一个多级排序：先按照姓名进行排序，得到 (A, 180) (B, 185) (C, 170) (D, 170) ；再对身高进行排序。由于排序算法不稳定，因此可能得到 (D, 170) (C, 170) (A, 180) (B, 185) 。</p>
<p>可以发现，学生 D 和 C 的位置发生了交换，姓名的有序性被破坏了，而这是我们不希望看到的。</p>
<p>:::</p>
<p>:::color2<br><strong>Q：哨兵划分中“从右往左查找”与“从左往右查找”的顺序可以交换吗？</strong></p>
<p>不行，当我们以最左端元素为基准数时，必须先“从右往左查找”再“从左往右查找”。这个结论有些反直觉，我们来剖析一下原因。</p>
<p>哨兵划分 partition() 的最后一步是交换 nums[left] 和 nums[i] 。完成交换后，基准数左边的元素都 &lt;&#x3D; 基准数，这就要求最后一步交换前 nums[left] &gt;&#x3D; nums[i] 必须成立。假设我们先“从左往右查找”，那么如果找不到比基准数更大的元素，则会在 i &#x3D;&#x3D; j 时跳出循环，此时可能 nums[j] &#x3D;&#x3D; nums[i] &gt; nums[left]。也就是说，此时最后一步交换操作会把一个比基准数更大的元素交换至数组最左端，导致哨兵划分失败。</p>
<p>举个例子，给定数组 [0, 0, 0, 0, 1] ，如果先“从左向右查找”，哨兵划分后数组为 [1, 0, 0, 0, 0] ，这个结果是不正确的。</p>
<p>再深入思考一下，如果我们选择 nums[right] 为基准数，那么正好反过来，必须先“从左往右查找”。</p>
<p>:::</p>
<p>:::color3<br><strong>Q：关于尾递归优化，为什么选短的数组能保证递归深度不超过 log⁡𝑛 ？</strong></p>
<p>递归深度就是当前未返回的递归方法的数量。每轮哨兵划分我们将原数组划分为两个子数组。在尾递归优化后，向下递归的子数组长度最大为原数组长度的一半。假设最差情况，一直为一半长度，那么最终的递归深度就是 log⁡𝑛 。</p>
<p>回顾原始的快速排序，我们有可能会连续地递归长度较大的数组，最差情况下为 𝑛、𝑛−1、…、2、1 ，递归深度为 𝑛 。尾递归优化可以避免这种情况出现。</p>
<p>:::</p>
<p>:::color5<br><strong>Q：当数组中所有元素都相等时，快速排序的时间复杂度是 𝑂(𝑛</strong><sup><strong>2</strong></sup><strong>) 吗？该如何处理这种退化情况？</strong></p>
<p>是的。对于这种情况，可以考虑通过哨兵划分将数组划分为三个部分：小于、等于、大于基准数。仅向下递归小于和大于的两部分。在该方法下，输入元素全部相等的数组，仅一轮哨兵划分即可完成排序。</p>
<p>:::</p>
<p>:::color4<br><strong>Q：桶排序的最差时间复杂度为什么是 𝑂(𝑛</strong><sup><strong>2</strong></sup><strong>) ？</strong></p>
<p>最差情况下，所有元素被分至同一个桶中。如果我们采用一个 𝑂(𝑛<sup>2</sup>) 算法来排序这些元素，则时间复杂度为 𝑂(𝑛<sup>2</sup>) 。</p>
<p>:::</p>
<p><em><strong><font style="color:#ED740C;"></font></strong></em></p>
<p><em><strong><font style="color:#ED740C;"></font></strong></em></p>
<p><em><strong><font style="color:#ED740C;"></font></strong></em></p>
<p><em><strong><font style="color:#ED740C;"></font></strong></em></p>
<p><em><strong><font style="color:#ED740C;"></font></strong></em></p>
<p><em><strong><font style="color:#ED740C;"></font></strong></em></p>
<p><em><strong><font style="color:#ED740C;"></font></strong></em></p>
<p><em><strong><font style="color:#ED740C;"></font></strong></em></p>
<p><em><strong><font style="color:#ED740C;"></font></strong></em></p>
<p><em><strong><font style="color:#ED740C;"></font></strong></em></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>排序算法</div>
      <div>http://example.com/2025/01/08/排序算法/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年1月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/01/07/hello-world/" title="HelloWorld">
                        <span class="hidden-mobile">HelloWorld</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'zh-cn'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/zh-cn.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
